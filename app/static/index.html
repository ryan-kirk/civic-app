<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CivicWatch Explorer</title>
  <style>
    :root {
      --bg: #f3efe6;
      --ink: #1f2421;
      --muted: #5e645f;
      --panel: #fffdf8;
      --accent: #0e7490;
      --accent-2: #155e75;
      --line: #d7d2c8;
      --ok: #0f766e;
      --warn: #b45309;
      --chip: #edf6f8;
    }
    [hidden] { display: none !important; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: "Avenir Next", "Segoe UI", sans-serif;
      color: var(--ink);
      overflow-x: hidden;
      overflow-y: auto;
      background:
        radial-gradient(1000px 500px at 10% -10%, #dce8e9 0%, transparent 60%),
        radial-gradient(900px 450px at 90% -5%, #efe6d5 0%, transparent 60%),
        var(--bg);
    }
    .wrap {
      max-width: 1200px;
      min-height: 100vh;
      height: auto;
      margin: 0 auto;
      padding: 16px;
      display: grid;
      grid-template-rows: auto auto minmax(0, 1fr);
      gap: 12px;
    }
    .hero {
      margin-bottom: 6px;
      display: grid;
      grid-template-columns: auto minmax(0, 1fr);
      align-items: end;
      gap: 6px 16px;
    }
    .hero h1 { margin: 0; font-size: clamp(1.7rem, 4vw, 2.5rem); letter-spacing: .02em; line-height: 1.05; }
    .hero p { margin: 0; color: var(--muted); max-width: none; line-height: 1.25; }
    .hero-note {
      grid-column: 1 / -1;
      margin-top: 2px;
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .hero-note span {
      font-size: .76rem;
      border: 1px solid #d9e4e8;
      border-radius: 999px;
      padding: 4px 8px;
      background: rgba(255,255,255,.7);
      color: #37525c;
    }
    .filter-bar {
      background: rgba(255, 253, 248, 0.9);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      display: grid;
      gap: 6px;
    }
    .filter-bar-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }
    .filter-bar-title { font-size: .8rem; color: var(--muted); font-weight: 600; }
    .filter-clear {
      background: transparent;
      color: #0b4d5f;
      border: 0;
      padding: 0;
      font-size: .8rem;
      font-weight: 600;
      cursor: pointer;
    }
    .filter-clear:hover { text-decoration: underline; }
    .filter-chip-row {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      min-height: 28px;
      align-items: center;
    }
    .filter-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border-radius: 999px;
      border: 1px solid #c8dfe6;
      background: #eef7fa;
      color: #0b4d5f;
      padding: 3px 9px;
      font-size: .78rem;
    }
    .filter-chip.topic { background: #eef8fb; border-color: #c8dfe6; color: #0b4d5f; }
    .filter-chip.entity { background: #f2f7ee; border-color: #d5e2c7; color: #36511e; }
    .filter-chip.meeting { background: #fbf2e8; border-color: #ead3b7; color: #7a4b14; }
    .filter-chip button {
      background: transparent;
      border: 0;
      color: inherit;
      padding: 0;
      font-size: .8rem;
      line-height: 1;
      cursor: pointer;
      font-weight: 700;
    }
    .filter-empty { color: var(--muted); font-size: .8rem; }

    .panel {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 10px 25px rgba(0,0,0,.04);
    }
    .top-explorer-controls {
      padding: 10px 12px 10px 12px;
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      align-items: start;
      gap: 8px;
    }
    .top-explorer-controls.compact {
      gap: 6px;
      padding: 8px 10px 8px 10px;
    }
    .top-explorer-controls > * { min-width: 0; }
    .top-panel-compact-toggle {
      position: static;
      z-index: 1;
      grid-column: 1 / -1;
      justify-self: end;
      align-self: start;
      border: 1px solid #d8d1c4;
      background: #fff;
      color: #244b56;
      border-radius: 999px;
      padding: 5px 9px;
      font-size: .72rem;
      font-weight: 700;
      line-height: 1;
      white-space: nowrap;
      margin-bottom: 2px;
    }
    .top-panel-compact-toggle:hover { transform: none; background: #fbfaf6; }
    .top-panel-control-row {
      grid-column: 1 / -1;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 2px;
    }
    .top-panel-mode-toggle {
      display: inline-flex;
      gap: 6px;
      align-items: center;
    }
    .top-panel-mode-toggle button {
      border: 1px solid #d8d1c4;
      background: #fff;
      color: #244b56;
      border-radius: 999px;
      padding: 5px 9px;
      font-size: .72rem;
      font-weight: 700;
      line-height: 1;
      white-space: nowrap;
    }
    .top-panel-mode-toggle button.active {
      background: #dceef3;
      border-color: #86c7d8;
      color: #0c4a60;
    }
    .top-panel-mode-toggle button:hover { transform: none; background: #fbfaf6; }
    .top-panel-mode-toggle button.active:hover { background: #dceef3; }
    .top-filter-stack {
      display: grid;
      gap: 10px;
      align-content: start;
    }
    .top-explorer-controls.compact .top-filter-stack { gap: 6px; }
    .top-search-panel {
      margin: 0;
      background: #fff;
      padding: 10px;
      min-height: 0;
      display: grid;
      gap: 6px;
    }
    .top-search-panel-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .top-search-panel-title {
      font-size: .8rem;
      color: var(--muted);
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: .03em;
    }
    .top-search-panel .hint { margin: 0; }
    .top-explorer-controls.compact .top-search-panel .hint { display: none; }
    .top-explorer-controls.compact .top-search-preview { display: none !important; }
    .top-explorer-controls.compact .top-search-panel,
    .top-explorer-controls.compact .filter-bar,
    .top-explorer-controls.compact .facet-mini-panel,
    .top-explorer-controls.compact .top-focus-panel { padding: 8px; }
    .top-search-preview {
      border-top: 1px solid #ece5d7;
      padding-top: 6px;
      display: grid;
      gap: 5px;
    }
    .top-search-preview-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-size: .7rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .05em;
      font-weight: 700;
    }
    .top-search-preview-list {
      display: grid;
      gap: 5px;
    }
    .top-search-hit {
      border: 1px solid #e6dfd2;
      border-radius: 8px;
      padding: 6px 8px;
      background: #fbfaf6;
      display: grid;
      gap: 3px;
    }
    .top-search-hit .hit-head {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }
    .top-search-hit .hit-head button {
      background: transparent;
      border: 0;
      padding: 0;
      font: inherit;
      color: #0b4d5f;
      font-weight: 700;
      cursor: pointer;
      text-align: left;
    }
    .top-search-hit .hit-head button:hover { text-decoration: underline; }
    .top-search-hit .hit-meta {
      font-size: .74rem;
      color: #59635e;
      line-height: 1.25;
    }
    .top-explorer-controls .top-focus-panel {
      border: 1px solid #e6dfd2;
      border-radius: 10px;
      background: #fbfaf6;
      padding: 8px;
      display: grid;
      gap: 5px;
    }
    .top-focus-head-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .top-explorer-controls .top-focus-panel .top-focus-head {
      font-size: .74rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .05em;
      font-weight: 700;
    }
    .top-focus-clear-btn {
      border: 1px solid #d8d1c4;
      background: #fff;
      color: #4a554f;
      border-radius: 999px;
      width: 22px;
      height: 22px;
      line-height: 1;
      font-size: .9rem;
      font-weight: 700;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }
    .top-focus-clear-btn:hover { background: #fbfaf6; }
    .top-explorer-controls .top-focus-panel .top-focus-sub {
      font-size: .82rem;
      color: #45504b;
      line-height: 1.3;
    }
    .top-explorer-controls.compact .top-focus-panel .top-focus-sub { display: none; }
    .top-explorer-controls.compact .top-focus-panel { gap: 4px; }
    .top-explorer-controls.compact .top-focus-panel .focus-card {
      padding: 8px;
    }
    .top-explorer-controls.compact .top-focus-panel .focus-card .focus-card-meta,
    .top-explorer-controls.compact .top-focus-panel .focus-card .focus-card-stats {
      display: none;
    }
    .top-explorer-controls.compact .top-focus-panel #topSelectedConnectionPanel .focus-card-actions {
      display: none;
    }
    .top-explorer-controls.compact .top-focus-panel #topSelectedConnectionSub {
      font-size: .78rem;
      line-height: 1.2;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .top-explorer-controls .top-focus-panel .focus-card {
      margin: 0;
      background: #fff;
    }
    .top-explorer-controls .top-focus-panel .focus-card[hidden] { display: none !important; }
    .focus-card-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }
    .focus-card-actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .focus-card-actions button {
      border: 1px solid #d8d1c4;
      background: #fff;
      color: #244b56;
      border-radius: 999px;
      padding: 4px 8px;
      font-size: .7rem;
      font-weight: 700;
      line-height: 1;
    }
    .focus-card-actions button:hover { transform: none; background: #fbfaf6; }
    .top-explorer-controls .filter-bar {
      margin: 0;
      background: #fff;
      padding: 10px;
      min-height: 100%;
    }
    .top-explorer-controls .filter-bar-head { margin-bottom: 6px; }
    .top-explorer-controls .filter-chip-row { min-height: 1.2rem; }
    .top-explorer-controls .filter-empty { line-height: 1.25; }
    .top-explorer-controls.compact .filter-empty { display: none; }
    .top-explorer-controls .entity-panel-header {
      border-bottom: 0;
      padding-bottom: 0;
    }
    .top-explorer-controls .entity-panel-header .sub {
      font-size: .75rem;
      line-height: 1.2;
      margin-bottom: 4px;
      color: #666f69;
    }
    .top-explorer-controls.compact .entity-panel-header .sub { display: none; }
    .top-explorer-controls .facet-control-grid {
      display: grid;
      gap: 8px;
    }
    .top-explorer-controls .facet-mini-panel {
      border: 1px solid #e6dfd2;
      border-radius: 10px;
      background: rgba(255,255,255,.8);
      padding: 8px;
      display: grid;
      gap: 6px;
    }
    .top-explorer-controls.compact .facet-mini-panel { gap: 4px; }
    .top-explorer-controls .facet-mini-title {
      margin: 0;
      font-size: .68rem;
      color: #6a736d;
      text-transform: uppercase;
      letter-spacing: .07em;
      font-weight: 700;
    }
    .top-explorer-controls .controls-row {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      align-items: start;
    }
    .top-explorer-controls .search-row { margin: 0; }
    .top-explorer-controls .search-row .search-box { min-width: 0; }
    .top-explorer-controls .search-type-row {
      display: grid;
      gap: 4px;
      margin: 0;
    }
    .top-explorer-controls .search-type-label {
      font-size: .7rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .05em;
      font-weight: 700;
    }
    .top-explorer-controls .search-type-filters {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
    }
    .top-explorer-controls .search-type-btn {
      border: 1px solid #cfd8cc;
      background: #fff;
      color: #234b57;
      border-radius: 999px;
      padding: 4px 8px;
      font-size: .74rem;
      line-height: 1;
      font-weight: 700;
      cursor: pointer;
    }
    .top-explorer-controls .search-type-btn.active {
      background: #e3f5fb;
      border-color: #82bfd3;
      color: #0c4a60;
    }
    .top-explorer-controls .status-row {
      display: grid;
      grid-template-columns: 1fr;
      gap: 6px;
    }
    .top-explorer-controls .status-row .status.browse { margin-top: 0; min-width: 0; }
    .top-explorer-controls .hint { font-size: .76rem; line-height: 1.25; }
    .top-explorer-controls .lens-row { gap: 5px; }
    .top-explorer-controls .facet-mini-panel .lens-row { margin-top: 0; }
    .top-explorer-controls .facet-mini-panel .search-type-filters { gap: 5px; }
    .top-explorer-controls .facet-view-tabs { margin-top: 0; }
    .top-explorer-controls .lens-btn,
    .top-explorer-controls .tab-btn {
      padding: 5px 10px;
      border-radius: 999px;
      font-size: .78rem;
    }
    .facet-shortcut-btn {
      border-style: dashed;
      background: #fff;
    }
    .top-explorer-controls .search-row button {
      padding: 9px 12px;
      font-size: .9rem;
    }
    .pane-head {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 8px;
      margin-bottom: 10px;
      padding-bottom: 8px;
      border-bottom: 1px solid #e7e1d6;
    }
    .pane-head h2 {
      margin: 0;
      font-size: .95rem;
      letter-spacing: .02em;
    }
    .pane-head .sub {
      color: var(--muted);
      font-size: .78rem;
    }
    .workspace {
      display: grid;
      grid-template-columns: minmax(0, 2fr) minmax(300px, 1fr);
      gap: 16px;
      align-items: stretch;
      min-height: 0;
      height: 100%;
    }
    .graph-walk-panel {
      display: grid;
      grid-template-rows: auto auto auto minmax(0, 1fr);
      gap: 10px;
      padding: 12px;
      min-height: 0;
      height: 100%;
      overflow-y: auto;
      overflow-x: hidden;
    }
    .graph-walk-head {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
      padding-bottom: 8px;
      border-bottom: 1px solid #e7e1d6;
    }
    .graph-walk-head h2 { margin: 0; font-size: .95rem; letter-spacing: .02em; }
    .graph-walk-head .sub { color: var(--muted); font-size: .8rem; }
    .graph-walk-actions {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      flex-wrap: wrap;
    }
    .graph-walk-actions button {
      border: 1px solid #d8d1c4;
      background: #fff;
      color: #244b56;
      border-radius: 999px;
      padding: 5px 9px;
      font-size: .72rem;
      font-weight: 700;
      line-height: 1;
      white-space: nowrap;
    }
    .graph-walk-actions button:hover { transform: none; background: #fbfaf6; }
    .graph-walk-actions button[aria-pressed="true"] {
      background: #eef8fb;
      border-color: #9fd4e2;
      color: #0d5f77;
    }
    .graph-walk-breadcrumbs {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      min-height: 1.5rem;
    }
    .graph-walk-crumb {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      border: 1px solid #dcd5c8;
      background: #fff;
      color: #234b57;
      border-radius: 999px;
      padding: 4px 8px;
      font-size: .75rem;
      cursor: pointer;
    }
    .graph-walk-crumb.active {
      background: #e8f7fb;
      border-color: #86c7d8;
      color: #0c4a60;
      box-shadow: inset 0 0 0 1px #c1e7f0;
    }
    .graph-walk-crumb-arrow {
      color: #7a847e;
      font-size: .8rem;
      user-select: none;
    }
    .graph-walk-layout {
      display: grid;
      grid-template-columns: minmax(0, 2.1fr) minmax(260px, 1fr);
      gap: 10px;
      min-height: 0;
    }
    .graph-walk-canvas-panel,
    .graph-walk-detail-panel {
      border: 1px solid #e6dfd2;
      border-radius: 10px;
      background: #fbfaf6;
      padding: 10px;
      min-height: 0;
    }
    .graph-walk-canvas-wrap {
      border: 1px solid #e6dfd2;
      border-radius: 10px;
      background: #fff;
      min-height: 420px;
      height: 100%;
      overflow: hidden;
      position: relative;
    }
    .graph-walk-svg {
      display: block;
      width: 100%;
      height: 100%;
      min-height: 420px;
      background:
        radial-gradient(circle at 20% 20%, rgba(134,199,216,.10), transparent 45%),
        radial-gradient(circle at 80% 70%, rgba(23,117,148,.06), transparent 50%),
        #fff;
    }
    .graph-walk-empty {
      border: 1px dashed #d7d2c8;
      border-radius: 10px;
      padding: 12px;
      color: var(--muted);
      background: #fbfaf6;
      font-size: .85rem;
    }
    .graph-node { cursor: pointer; }
    .graph-node circle {
      stroke: #d0d9cd;
      stroke-width: 1.2;
      fill: #fff;
    }
    .graph-node.focus circle {
      fill: #e7f6fb;
      stroke: #69b7cf;
      stroke-width: 2;
    }
    .graph-node.trail circle {
      fill: #f4fbfd;
      stroke: #86c7d8;
    }
    .graph-node.selected-connection circle {
      fill: #fff6df;
      stroke: #e0b74c;
      stroke-width: 2;
    }
    .graph-node text {
      font-size: 12px;
      font-weight: 700;
      fill: #24312d;
      pointer-events: none;
    }
    .graph-node .graph-node-sub {
      font-size: 10px;
      font-weight: 500;
      fill: #64706a;
    }
    .graph-edge {
      stroke: #c8d3c9;
      stroke-width: 1.5;
      opacity: .95;
    }
    .graph-edge.selected {
      stroke: #d59c26;
    }
    .graph-edge-label {
      font-size: 10px;
      fill: #6a736d;
      paint-order: stroke;
      stroke: rgba(255,255,255,.95);
      stroke-width: 3px;
      stroke-linejoin: round;
    }
    .graph-walk-detail-panel {
      display: grid;
      gap: 10px;
      align-content: start;
      max-height: 100%;
      overflow-y: auto;
    }
    .graph-walk-list {
      display: grid;
      gap: 6px;
      max-height: 320px;
      overflow-y: auto;
    }
    .graph-walk-row {
      border: 1px solid #e8e2d6;
      border-radius: 8px;
      background: #fff;
      padding: 8px;
      display: grid;
      gap: 4px;
    }
    .graph-walk-row.active {
      border-color: #e0b74c;
      background: #fff9ea;
      box-shadow: inset 0 0 0 1px #f1d18c;
    }
    .graph-walk-row-head {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      align-items: baseline;
    }
    .graph-walk-row-title {
      background: transparent;
      border: 0;
      color: #0b4d5f;
      padding: 0;
      font: inherit;
      text-align: left;
      font-weight: 700;
      cursor: pointer;
    }
    .graph-walk-row-title:hover { text-decoration: underline; }
    .graph-walk-row-meta {
      font-size: .74rem;
      color: var(--muted);
      line-height: 1.25;
    }
    .graph-walk-row-actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .graph-walk-row-actions button {
      border: 1px solid #d8d1c4;
      background: #fff;
      color: #244b56;
      border-radius: 999px;
      padding: 4px 8px;
      font-size: .7rem;
      font-weight: 700;
      line-height: 1;
    }
    .graph-walk-row-actions button:hover { transform: none; background: #fbfaf6; }
    .main-col { min-width: 0; min-height: 0; height: 100%; overflow-y: auto; padding-right: 4px; }
    .side-col { min-width: 0; min-height: 0; height: 100%; overflow: hidden; }
    .sticky {
      position: sticky;
      top: 0;
      height: 100%;
      max-height: 100%;
      overflow: hidden;
    }

    form { display: grid; gap: 12px; }
    .grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(6, minmax(0, 1fr));
    }
    label { font-size: .85rem; color: var(--muted); display: block; margin-bottom: 4px; }
    input, select {
      width: 100%;
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 10px 11px;
      font-size: 0.95rem;
      background: white;
    }
    .hint { margin-top: 4px; font-size: .78rem; color: var(--muted); }
    .col-2 { grid-column: span 2; }
    .col-1 { grid-column: span 1; }
    .checks { display: flex; gap: 18px; align-items: center; flex-wrap: wrap; }
    .checks label { margin: 0; color: var(--ink); font-size: .9rem; }
    .checks input { width: auto; margin-right: 6px; }

    button {
      appearance: none;
      border: 0;
      border-radius: 10px;
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      color: white;
      padding: 12px 14px;
      font-weight: 600;
      cursor: pointer;
      transition: transform .12s ease, opacity .12s ease;
    }
    button:hover { transform: translateY(-1px); }
    button:disabled { opacity: .6; cursor: not-allowed; transform: none; }

    .status { margin-top: 10px; font-size: .92rem; color: var(--muted); min-height: 1.25rem; }
    .status.ingest { margin-top: 10px; }
    .status-label {
      margin-top: 10px;
      font-size: .72rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .04em;
      font-weight: 700;
    }
    .status.browse {
      margin-top: 2px;
      padding: 6px 8px;
      border: 1px solid #e4dfd3;
      border-radius: 8px;
      background: #fff;
      font-size: .82rem;
      min-height: 0;
    }

    .progress-wrap { margin-top: 8px; }
    .progress-track {
      width: 100%;
      height: 10px;
      border-radius: 999px;
      background: #e8e4db;
      border: 1px solid var(--line);
      overflow: hidden;
    }
    .progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      transition: width .2s ease;
    }

    .summary {
      margin-top: 18px;
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px;
    }
    .kpi {
      background: #f8f6ef;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px;
    }
    .kpi .k { color: var(--muted); font-size: .8rem; }
    .kpi .v { font-weight: 700; font-size: 1.1rem; margin-top: 4px; }

    .related {
      margin-top: 12px;
      padding: 10px;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #f8f6ef;
      font-size: .85rem;
      color: var(--muted);
    }
    .coverage-panel {
      margin-top: 10px;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #fbfaf6;
      padding: 10px;
      display: grid;
      gap: 8px;
    }
    .coverage-grid {
      display: grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap: 6px;
    }
    .coverage-kpi {
      border: 1px solid #e4dfd3;
      background: white;
      border-radius: 8px;
      padding: 6px 8px;
    }
    .coverage-kpi .k { font-size: .7rem; color: var(--muted); }
    .coverage-kpi .v { font-size: .9rem; font-weight: 700; }
    .range-cache-status {
      border: 1px solid #e4dfd3;
      background: white;
      border-radius: 8px;
      padding: 8px;
      font-size: .82rem;
      color: #3e4642;
    }
    .range-list { display: grid; gap: 5px; max-height: 120px; overflow-y: auto; }
    .range-row {
      border: 1px solid #eee8da;
      background: #fff;
      border-radius: 8px;
      padding: 6px 8px;
      font-size: .78rem;
    }
    .range-row button {
      background: transparent;
      color: #0b4d5f;
      border: 0;
      padding: 0;
      font: inherit;
      font-weight: 600;
      cursor: pointer;
      text-align: left;
    }
    .browse-panel {
      margin-top: 10px;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #fff;
      padding: 10px;
      display: grid;
      gap: 8px;
    }
    .browse-section {
      border: 1px solid #e6dfd2;
      border-radius: 10px;
      background: #faf8f2;
      padding: 8px;
      display: grid;
      gap: 6px;
    }
    .browse-section-title {
      font-size: .78rem;
      color: var(--muted);
      font-weight: 600;
      letter-spacing: .02em;
    }
    .browse-actions { display: flex; gap: 8px; flex-wrap: wrap; }
    .browse-actions button { padding: 8px 10px; font-size: .85rem; }
    .browse-list { display: grid; gap: 6px; max-height: 180px; overflow-y: auto; }
    .browse-list.compact { max-height: 240px; }
    .browse-row {
      border: 1px solid #e8e2d6;
      border-radius: 8px;
      background: #fffdf7;
      padding: 7px 8px;
      font-size: .8rem;
    }
    .browse-row.active {
      border-color: #86c7d8;
      background: #eef8fb;
      box-shadow: inset 0 0 0 1px #c7e7f0;
    }
    .browse-row button {
      background: transparent;
      border: 0;
      color: #0b4d5f;
      padding: 0;
      font: inherit;
      font-weight: 700;
      cursor: pointer;
      text-align: left;
    }
    .browse-row button:hover { text-decoration: underline; }

    .results { margin-top: 18px; display: grid; gap: 12px; }
    .meeting-master-detail {
      margin-top: 10px;
      display: grid;
      gap: 10px;
    }
    .meeting-list-panel,
    .meeting-detail-panel {
      border: 1px solid #e6dfd2;
      border-radius: 10px;
      background: #fbfaf6;
      padding: 10px;
      display: grid;
      gap: 8px;
    }
    .meeting-list-panel .browse-list {
      max-height: 220px;
      background: transparent;
    }
    .meeting-list-row {
      border: 1px solid #e8e2d6;
      border-radius: 8px;
      background: #fff;
      padding: 8px;
      display: grid;
      gap: 4px;
    }
    .meeting-list-row.active {
      border-color: #86c7d8;
      background: #eef8fb;
      box-shadow: inset 0 0 0 1px #c7e7f0;
    }
    .meeting-list-row button {
      background: transparent;
      border: 0;
      padding: 0;
      text-align: left;
      color: #0b4d5f;
      font-weight: 700;
      font-size: .84rem;
      cursor: pointer;
    }
    .meeting-list-row button:hover { text-decoration: underline; }
    .meeting-list-stats {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .meeting-list-stats span {
      font-size: .72rem;
      color: #4a534f;
      border: 1px solid #ddd6ca;
      background: #fffdf7;
      border-radius: 999px;
      padding: 2px 7px;
    }
    .meeting-detail-head {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 8px;
      border-bottom: 1px solid #e7e1d6;
      padding-bottom: 6px;
    }
    .meeting-detail-head-main { min-width: 0; }
    .meeting-detail-head h3 {
      margin: 0;
      font-size: .92rem;
      letter-spacing: .02em;
    }
    .meeting-detail-head .sub {
      color: var(--muted);
      font-size: .78rem;
    }
    .meeting-detail-toggle {
      border: 1px solid #d8d1c4;
      background: #fff;
      color: #244b56;
      border-radius: 999px;
      padding: 5px 9px;
      font-size: .72rem;
      font-weight: 700;
      line-height: 1;
      white-space: nowrap;
    }
    .meeting-detail-toggle:hover { transform: none; background: #fbfaf6; }
    .meeting-detail-panel.collapsed .results { display: none; }
    .results-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border: 1px solid #e6dfd2;
      border-radius: 10px;
      background: #fbfaf6;
    }
    .results-head-title { font-size: .82rem; color: var(--muted); font-weight: 700; letter-spacing: .03em; text-transform: uppercase; }
    .results-head-sub { font-size: .8rem; color: #45504b; }
    .meeting {
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #fff;
      padding: 12px;
    }
    .meeting h3 { margin: 0 0 4px; font-size: 1rem; }
    .meta { font-size: .86rem; color: var(--muted); margin-bottom: 8px; }
    .meta-link { color: #0b4d5f; text-decoration: none; cursor: pointer; }
    .meta-link:hover { text-decoration: underline; }
    .item {
      padding: 8px;
      border: 1px solid #ece7dc;
      border-radius: 8px;
      margin-top: 6px;
      background: #fffcf5;
    }
    .topic-row { margin-top: 5px; display: flex; flex-wrap: wrap; gap: 6px; }
    .chip {
      border: 1px solid #c9dbe0;
      border-radius: 999px;
      background: var(--chip);
      padding: 2px 8px;
      font-size: .75rem;
      color: #0b4d5f;
      cursor: pointer;
    }
    .chip.active { background: #c8e8f0; border-color: #7ec3d7; }
    .signals { font-size: .8rem; color: var(--warn); margin-top: 4px; }
    .doc-list { margin-top: 6px; display: grid; gap: 4px; }
    .doc-link {
      display: inline-block;
      font-size: .8rem;
      color: #0b4d5f;
      text-decoration: none;
      border-bottom: 1px dotted #9cc5d1;
      width: fit-content;
    }
    .doc-link:hover { text-decoration: underline; }
    .minutes {
      margin-top: 8px;
      border: 1px dashed #d7d2c8;
      border-radius: 8px;
      background: #f9f9f6;
      padding: 8px;
    }
    .minutes-title { font-size: .78rem; color: var(--muted); margin-bottom: 4px; }
    .minutes-row { font-size: .8rem; color: #2d3431; margin-top: 4px; }
    .minutes-row a { color: #0b4d5f; text-decoration: none; }
    .minutes-row a:hover { text-decoration: underline; }
    .entity-panel {
      margin-top: 10px;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #fbfaf6;
      padding: 10px;
    }
    .startup-panel {
      margin-top: 10px;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #fff;
      padding: 10px;
    }
    .entity-title { font-size: .8rem; color: var(--muted); margin-bottom: 6px; }
    .entity-list { display: flex; flex-wrap: wrap; gap: 6px; }
    .entity-chip {
      border: 1px solid #d8dad1;
      background: #f4f6ee;
      color: #374133;
      border-radius: 999px;
      padding: 3px 8px;
      font-size: .75rem;
      cursor: pointer;
    }
    .entity-chip.active {
      border-color: #7ec3d7;
      background: #dff2f7;
      color: #0b4d5f;
      box-shadow: inset 0 0 0 1px #bfe3ed;
    }
    .search-panel {
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #f8f6ef;
      padding: 10px;
      display: grid;
      grid-template-rows: auto auto auto auto auto auto auto minmax(0, 1fr);
      gap: 8px;
      height: 100%;
      min-height: 0;
    }
    .search-panel.controls-moved {
      display: flex;
      flex-direction: column;
      padding-top: 8px;
    }
    .search-panel.controls-moved .sidebar-scroll {
      flex: 1 1 auto;
      min-height: 0;
    }
    .entity-panel-header {
      display: grid;
      gap: 4px;
      padding-bottom: 6px;
      border-bottom: 1px solid #e7e1d6;
    }
    .entity-panel-header .entity-title {
      margin: 0;
      font-size: .95rem;
      color: var(--ink);
      font-weight: 700;
    }
    .entity-panel-header .sub {
      font-size: .78rem;
      color: var(--muted);
      line-height: 1.3;
    }
    .lens-row {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin-top: 4px;
    }
    .lens-btn {
      border: 1px solid #d6ddd1;
      border-radius: 999px;
      background: #fff;
      color: #36403a;
      padding: 4px 8px;
      font-size: .74rem;
      cursor: pointer;
    }
    .lens-btn:hover { background: #f5f8f1; }
    .sidebar-scroll {
      min-height: 0;
      overflow-y: auto;
      padding-right: 4px;
      padding-bottom: 8px;
      overscroll-behavior: contain;
    }
    .view-tabs { display: flex; gap: 6px; flex-wrap: wrap; }
    .tab-btn {
      border: 1px solid #c9dbe0;
      border-radius: 999px;
      background: #fff;
      color: #0b4d5f;
      padding: 4px 10px;
      font-size: .78rem;
      cursor: pointer;
    }
    .tab-btn.active {
      background: #dceef3;
      border-color: #86c7d8;
      font-weight: 600;
    }
    .search-row { display: flex; gap: 8px; flex-wrap: wrap; }
    .search-row input { flex: 1 1 240px; }
    .search-box { position: relative; }
    .suggestions {
      position: absolute;
      left: 0;
      right: 0;
      top: calc(100% + 4px);
      z-index: 30;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: white;
      box-shadow: 0 10px 25px rgba(0,0,0,.08);
      max-height: 220px;
      overflow-y: auto;
    }
    .suggestion-item {
      width: 100%;
      border: 0;
      border-bottom: 1px solid #eee8da;
      background: #fff;
      text-align: left;
      padding: 8px 10px;
      color: var(--ink);
      cursor: pointer;
      border-radius: 0;
    }
    .suggestion-item:last-child { border-bottom: 0; }
    .suggestion-item:hover { background: #f7fbfc; }
    .suggestion-meta { font-size: .74rem; color: var(--muted); margin-top: 2px; }
    .search-results { margin-top: 8px; display: grid; gap: 6px; }
    .sidebar-section {
      margin-top: 10px;
      padding: 8px;
      border: 1px solid #e6dfd2;
      border-radius: 10px;
      background: rgba(255,255,255,.65);
    }
    .sidebar-group-title {
      margin-top: 10px;
      padding: 0 2px;
      font-size: .7rem;
      color: #6b746f;
      text-transform: uppercase;
      letter-spacing: .08em;
      font-weight: 700;
    }
    .sidebar-group-title:first-child { margin-top: 0; }
    .sidebar-section:first-child {
      margin-top: 0;
    }
    .sidebar-section-title {
      font-size: .76rem;
      font-weight: 700;
      letter-spacing: .03em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      user-select: none;
    }
    .sidebar-section-title::after {
      content: "âˆ’";
      color: #7a847e;
      font-size: .9rem;
      line-height: 1;
    }
    .sidebar-section.collapsed .sidebar-section-title { margin-bottom: 0; }
    .sidebar-section.collapsed .sidebar-section-title::after { content: "+"; }
    .sidebar-section.collapsed > *:not(.sidebar-section-title) { display: none !important; }
    .sidebar-section.operations {
      background: transparent;
      border-color: transparent;
      padding: 0;
    }
    .sidebar-section.operations .sidebar-section-title {
      padding: 8px;
      border: 1px solid #e6dfd2;
      border-radius: 10px;
      background: rgba(255,255,255,.65);
      margin-bottom: 8px;
    }
    .sidebar-section.facet-active {
      border-color: #86c7d8;
      box-shadow: inset 0 0 0 1px rgba(134,199,216,.22);
      background: #f4fbfd;
    }
    .sidebar-section.operations #operationsMount > .panel {
      margin: 0;
      box-shadow: none;
      background: rgba(255,255,255,.92);
    }
    .sidebar-section.operations #operationsMount .pane-head:first-child { margin-top: 0; }
    .sidebar-section.operations #operationsMount .pane-head { margin-bottom: 8px; padding-bottom: 6px; }
    .sidebar-section.operations #operationsMount .pane-head h2 { font-size: .86rem; }
    .sidebar-section.operations #operationsMount .pane-head .sub { font-size: .74rem; }
    .sidebar-section.operations #operationsMount .ops-compact-note {
      font-size: .72rem;
      color: var(--muted);
      border: 1px solid #e6dfd2;
      background: #fbfaf6;
      border-radius: 8px;
      padding: 6px 8px;
      line-height: 1.3;
      margin-bottom: 8px;
    }
    .sidebar-section.operations #operationsMount form { gap: 8px; }
    .sidebar-section.operations #operationsMount .grid {
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
    }
    .sidebar-section.operations #operationsMount .col-2,
    .sidebar-section.operations #operationsMount .col-1 {
      grid-column: span 1;
    }
    .sidebar-section.operations #operationsMount label { font-size: .74rem; margin-bottom: 2px; }
    .sidebar-section.operations #operationsMount input,
    .sidebar-section.operations #operationsMount select {
      padding: 8px 9px;
      font-size: .84rem;
      min-width: 0;
    }
    .sidebar-section.operations #operationsMount .hint {
      display: none;
    }
    .sidebar-section.operations #operationsMount .checks {
      gap: 8px;
      display: grid;
      align-items: start;
    }
    .sidebar-section.operations #operationsMount .checks label {
      font-size: .76rem;
      line-height: 1.2;
    }
    .sidebar-section.operations #operationsMount button {
      padding: 8px 10px;
      font-size: .8rem;
    }
    .sidebar-section.operations #operationsMount .status-label {
      margin-top: 6px;
      font-size: .68rem;
    }
    .sidebar-section.operations #operationsMount .status.ingest {
      margin-top: 4px;
      font-size: .78rem;
    }
    #operationsMount .summary { margin-top: 10px; }
    #operationsMount .summary { grid-template-columns: 1fr; gap: 6px; }
    #operationsMount .kpi { padding: 8px; }
    #operationsMount .kpi .v { font-size: .95rem; }
    #operationsMount .coverage-panel { margin-top: 10px; }
    #operationsMount .coverage-panel { padding: 8px; gap: 6px; }
    #operationsMount .coverage-grid { grid-template-columns: 1fr 1fr; gap: 5px; }
    #operationsMount .coverage-kpi { padding: 5px 6px; }
    #operationsMount .coverage-kpi .v { font-size: .82rem; }
    #operationsMount .range-list { max-height: 90px; }
    #operationsMount .range-row { font-size: .72rem; }
    #operationsMount .browse-panel { margin-top: 10px; }
    #operationsMount .browse-panel { padding: 8px; gap: 6px; }
    #operationsMount .browse-actions { display: grid; grid-template-columns: 1fr; gap: 6px; }
    #operationsMount .browse-actions button { width: 100%; }
    #operationsMount .browse-list { max-height: 120px; }
    #operationsMount .browse-row { font-size: .74rem; padding: 6px; }
    #operationsMount .browse-row .meta { font-size: .72rem; }
    .entity-context-empty {
      border: 1px dashed #d7d2c8;
      border-radius: 10px;
      padding: 10px;
      color: var(--muted);
      font-size: .85rem;
      background: #fbfaf6;
    }
    .context-row {
      border: 1px solid #e8e2d6;
      border-radius: 8px;
      background: #fffdf7;
      padding: 8px;
      font-size: .8rem;
    }
    .context-row strong {
      color: #0b4d5f;
      display: inline-block;
      margin-bottom: 2px;
    }
    .context-row .meta { margin-bottom: 4px; }
    .context-row .mention-context { font-size: .78rem; }
    .focus-card {
      border: 1px solid #e6dfd2;
      border-radius: 10px;
      background: #fbfaf6;
      padding: 10px;
      display: grid;
      gap: 6px;
    }
    .focus-card-title {
      font-size: .9rem;
      font-weight: 700;
      color: #23312d;
    }
    .focus-card-meta {
      font-size: .8rem;
      color: var(--muted);
      line-height: 1.35;
    }
    .focus-card-stats {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .focus-stat {
      border: 1px solid #dcd5c8;
      border-radius: 999px;
      padding: 3px 8px;
      background: #fff;
      font-size: .74rem;
      color: #4a534f;
    }
    .exploration-panel {
      margin-top: 10px;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #fbfaf6;
      padding: 10px;
      display: grid;
      gap: 8px;
    }
    .exploration-panel .exploration-grid {
      display: grid;
      gap: 8px;
    }
    .exploration-panel .sidebar-section {
      margin-top: 0;
      background: #fff;
    }
    .exploration-panel .sidebar-section.evidence-flat .sidebar-section-title {
      cursor: default;
    }
    .exploration-panel .sidebar-section.evidence-flat .sidebar-section-title::after {
      display: none;
    }
    #leftRelatedMount #relatedEntitiesSection {
      border: 0;
      background: transparent;
      padding: 0;
    }
    #leftRelatedMount #relatedEntitiesSection > .sidebar-section-title {
      display: none;
    }
    #leftConnectionsTopicsMount .related {
      margin-top: 0;
      padding: 8px;
      background: #fff;
    }
    #leftConnectionsMeetingsMount .meeting-list-panel {
      border: 0;
      background: transparent;
      padding: 0;
    }
    #leftConnectionsMeetingsMount .meeting-list-panel .browse-list {
      max-height: 200px;
    }
    #leftConnectionsMeetingsMount .meeting-list-panel .browse-section-title {
      display: none;
    }
    #leftEvidenceMeetingMount {
      display: grid;
      gap: 8px;
      margin-top: 8px;
    }
    #leftEvidenceMeetingMount .results-head,
    #leftEvidenceMeetingMount .meeting-detail-panel {
      margin: 0;
    }
    #leftEvidenceMeetingMount .meeting-detail-panel {
      background: #fff;
    }
    .exploration-panel .sidebar-section.collapsed > *:not(.sidebar-section-title) { display: none !important; }
    .exploration-panel .hint-inline {
      font-size: .8rem;
      color: var(--muted);
      border: 1px dashed #d8d1c4;
      border-radius: 8px;
      padding: 8px;
      background: #fffdf8;
    }
    .exploration-panel.minor .pane-head h2 { font-size: .9rem; }
    .exploration-panel.minor .pane-head .sub { font-size: .77rem; }
    .search-subtitle { margin-top: 10px; font-size: .78rem; color: var(--muted); }
    .search-result {
      border: 1px solid #e2ddd2;
      background: #fff;
      border-radius: 8px;
      padding: 8px;
      font-size: .82rem;
    }
    .search-result.featured {
      border-color: #cfe5ea;
      background: #fbfeff;
    }
    .search-result.related {
      border-color: #e5dfcf;
      background: #fffdf7;
    }
    .search-result.related.active-edge {
      border-color: #83bfd4;
      background: #eef8fb;
      box-shadow: inset 0 0 0 1px rgba(131,191,212,.25);
    }
    .node-result-card { display: grid; gap: 6px; }
    .node-result-head {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 6px;
    }
    .node-result-kind {
      display: inline-flex;
      align-items: center;
      border: 1px solid #d6e5ea;
      background: #eef8fb;
      color: #0b4d5f;
      border-radius: 999px;
      padding: 2px 7px;
      font-size: .72rem;
      line-height: 1;
      font-weight: 700;
      text-transform: lowercase;
    }
    .node-result-summary {
      font-size: .76rem;
      color: #54605a;
      line-height: 1.25;
    }
    .node-binding-row {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }
    .node-binding-chip {
      border: 1px solid #e4ded2;
      background: #fffdf7;
      color: #5a645f;
      border-radius: 999px;
      padding: 2px 6px;
      font-size: .68rem;
      line-height: 1;
    }
    .node-edge-preview {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      align-items: center;
    }
    .node-edge-preview .label {
      font-size: .7rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .05em;
      font-weight: 700;
    }
    .node-edge-chip {
      border: 1px solid #cfe5ea;
      background: #eef8fb;
      color: #0c4a60;
      border-radius: 999px;
      padding: 2px 7px;
      font-size: .7rem;
      line-height: 1;
      font-weight: 700;
    }
    .search-result button {
      background: transparent;
      color: #0b4d5f;
      border: 0;
      padding: 0;
      font: inherit;
      font-weight: 600;
      cursor: pointer;
      text-align: left;
    }
    .search-result button:hover { text-decoration: underline; }
    .runtime-panel {
      border: 1px solid var(--line);
      border-radius: 8px;
      background: #fff;
      padding: 8px;
      font-size: .8rem;
      color: #3e4642;
      display: grid;
      gap: 2px;
      min-height: 0;
    }
    #diagnosticsSection .runtime-panel {
      margin-top: 6px;
      background: rgba(255,255,255,.92);
    }
    .runtime-panel strong { font-size: .78rem; }
    .runtime-panel .meta { margin: 0; overflow-wrap: anywhere; }
    .runtime-ok { color: #0f766e; }
    .runtime-warn { color: #b45309; }
    .map-link {
      display: inline-block;
      margin-top: 4px;
      font-size: .78rem;
      color: #0b4d5f;
      text-decoration: none;
    }
    .map-link:hover { text-decoration: underline; }
    .flash-focus {
      animation: flashFocus 1.2s ease-out;
    }
    @keyframes flashFocus {
      0% { box-shadow: 0 0 0 0 rgba(14,116,144,.32); background-color: rgba(224,247,250,.55); }
      100% { box-shadow: 0 0 0 0 rgba(14,116,144,0); background-color: transparent; }
    }
    .mention-list { margin-top: 6px; display: grid; gap: 5px; }
    .mention-line {
      border-top: 1px dashed #e6e0d4;
      padding-top: 5px;
      color: #525954;
    }
    .mention-line:first-child { border-top: 0; padding-top: 0; }
    .mention-meta {
      font-size: .72rem;
      color: var(--muted);
      margin-bottom: 2px;
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .mention-context {
      font-size: .78rem;
      color: #343a36;
      line-height: 1.35;
    }
    .context-hit {
      background: #fff2bf;
      border-radius: 3px;
      padding: 0 2px;
    }
    .flow-jump-sticky {
      position: sticky;
      top: 0;
      z-index: 6;
      background: rgba(248, 246, 239, .95);
      backdrop-filter: blur(2px);
    }
    .focus-snapshot-sticky {
      position: sticky;
      top: 44px;
      z-index: 5;
      background: rgba(248, 246, 239, .97);
      backdrop-filter: blur(2px);
    }
    .focus-snapshot-panel {
      padding: 10px 12px;
    }
    .focus-snapshot-panel .pane-head {
      margin-bottom: 6px;
      padding-bottom: 6px;
      display: grid;
      grid-template-columns: auto 1fr auto;
      align-items: center;
      gap: 8px;
    }
    .focus-snapshot-panel .pane-head h2 {
      align-self: start;
    }
    .focus-snapshot-panel .pane-head .sub {
      align-self: start;
    }
    .focus-snapshot-panel.collapsed .focus-snapshot-body {
      display: none;
    }
    .focus-snapshot-toggle {
      border: 1px solid #d8d1c4;
      background: #fff;
      color: #244b56;
      border-radius: 999px;
      padding: 5px 9px;
      font-size: .72rem;
      font-weight: 700;
      line-height: 1;
      white-space: nowrap;
    }
    .focus-snapshot-toggle:hover { transform: none; background: #fbfaf6; }
    .focus-snapshot-body {
      display: grid;
      gap: 8px;
    }
    .focus-snapshot-card {
      border: 1px solid #e5ded1;
      border-radius: 10px;
      background: #fff;
      padding: 10px;
      display: grid;
      gap: 5px;
    }
    .focus-snapshot-title {
      font-weight: 800;
      color: #1f2a24;
      line-height: 1.2;
    }
    .focus-snapshot-meta {
      color: #55615b;
      font-size: .84rem;
      line-height: 1.3;
    }
    .focus-snapshot-connection {
      border-top: 1px dashed #e7e1d6;
      padding-top: 6px;
      margin-top: 2px;
      display: grid;
      gap: 4px;
    }
    .focus-snapshot-connection .label {
      font-size: .72rem;
      color: #6a736d;
      text-transform: uppercase;
      letter-spacing: .05em;
      font-weight: 700;
    }
    .focus-snapshot-actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .focus-snapshot-actions button {
      border: 1px solid #d8d1c4;
      background: #fff;
      color: #244b56;
      border-radius: 999px;
      padding: 4px 8px;
      font-size: .7rem;
      font-weight: 700;
      line-height: 1;
    }
    .focus-snapshot-actions button:hover { transform: none; background: #fbfaf6; }
    .focus-snapshot-preview {
      border: 1px dashed #e7e1d6;
      border-radius: 8px;
      background: #fcfbf7;
      padding: 8px;
      display: grid;
      gap: 8px;
    }
    .focus-snapshot-preview-section {
      display: grid;
      gap: 4px;
    }
    .focus-snapshot-preview-title {
      font-size: .72rem;
      color: #6a736d;
      text-transform: uppercase;
      letter-spacing: .05em;
      font-weight: 700;
    }
    .focus-snapshot-preview-list {
      display: grid;
      gap: 3px;
    }
    .focus-snapshot-preview-list .row {
      font-size: .79rem;
      color: #2e3532;
      line-height: 1.25;
    }
    .focus-snapshot-preview-list .row a {
      color: #0b4d5f;
      text-decoration: none;
    }
    .focus-snapshot-preview-list .row a:hover { text-decoration: underline; }
    .exploration-panel, .meeting-master-detail, .related {
      scroll-margin-top: 48px;
    }

    body.top-compact .wrap {
      gap: 8px;
      padding-top: 10px;
      padding-bottom: 10px;
    }
    body.top-compact .hero {
      margin-bottom: 0;
      gap: 4px 12px;
    }
    body.top-compact .hero h1 {
      font-size: clamp(1.45rem, 3.2vw, 2rem);
    }
    body.top-compact .hero p {
      font-size: .84rem;
      line-height: 1.2;
      max-width: 42ch;
    }
    body.top-compact .hero-note {
      display: none;
    }

    @media (max-width: 900px) {
      body { overflow: auto; }
      .wrap { height: auto; min-height: 100vh; display: block; padding: 24px 16px 48px; }
      .hero { grid-template-columns: 1fr; align-items: start; gap: 6px; }
      .hero-note { margin-top: 4px; }
      .top-explorer-controls { grid-template-columns: 1fr; }
      .top-explorer-controls .controls-row { grid-template-columns: 1fr; }
      .top-filter-stack { grid-template-columns: 1fr; }
      .grid { grid-template-columns: 1fr 1fr; }
      .col-2, .col-1 { grid-column: span 1; }
      .summary { grid-template-columns: 1fr; }
      .coverage-grid { grid-template-columns: 1fr 1fr; }
      .workspace { grid-template-columns: 1fr; height: auto; }
      .graph-walk-layout { grid-template-columns: 1fr; }
      .graph-walk-canvas-wrap, .graph-walk-svg { min-height: 320px; }
      .main-col, .side-col { overflow: visible; }
      .sticky { position: static; }
    }
  </style>
</head>
<body>
  <main class="wrap">
    <section class="hero">
      <h1>CivicWatch Explorer</h1>
      <p>Build historic civic context over time. Start from stored meetings, topics, and entities, then add new meeting ranges only where coverage is missing.</p>
      <div class="hero-note">
        <span>Investors: zoning + development signals</span>
        <span>Parents: schools + facilities changes</span>
        <span>Citizens: ordinances + enforcement context</span>
      </div>
    </section>
    <section id="filterBarPanel" class="filter-bar">
      <div class="filter-bar-head">
        <div class="filter-bar-title">Active Global Filters</div>
        <button id="clearAllFiltersBtn" type="button" class="filter-clear">Clear All</button>
      </div>
      <div id="activeFilterChips" class="filter-chip-row"></div>
      <div class="filter-empty">Filters apply across meeting results and entity discovery.</div>
    </section>
    <section id="topExplorerControlsPanel" class="panel top-explorer-controls">
      <div class="top-panel-control-row">
        <div class="top-panel-mode-toggle" role="group" aria-label="Main view mode">
          <button id="workbenchViewBtn" type="button" class="active" aria-pressed="true">Workbench</button>
          <button id="graphWalkViewBtn" type="button" aria-pressed="false">Graph Walk</button>
        </div>
        <button id="topExplorerCompactToggle" type="button" class="top-panel-compact-toggle" aria-expanded="true">Compact</button>
      </div>
      <div id="topSearchMount"></div>
      <div id="topFilterCol" class="top-filter-stack">
        <div id="topFilterMount"></div>
        <div id="topFilterControlsMount"></div>
      </div>
      <div id="topFocusPanel" class="top-focus-panel" hidden>
        <div class="top-focus-head-row">
          <div class="top-focus-head">Current Focus</div>
          <button id="clearCurrentFocusBtn" type="button" class="top-focus-clear-btn" title="Clear current focus and selected connection" aria-label="Clear current focus">x</button>
        </div>
        <div id="entityContextSummary" class="top-focus-sub">No item selected.</div>
        <div id="focusDetailsCard" class="focus-card"></div>
        <div id="topSelectedConnectionPanel" class="focus-card" hidden>
          <div class="focus-card-head">
            <div class="focus-card-title">Selected Connection</div>
            <div class="focus-card-actions">
              <button id="backToFocusNodeBtn" type="button">Back To Node</button>
              <button id="clearSelectedConnectionBtn" type="button">Clear</button>
            </div>
          </div>
          <div id="topSelectedConnectionSub" class="focus-card-meta">No connection selected.</div>
          <div id="topSelectedConnectionStats" class="focus-card-stats"></div>
        </div>
      </div>
    </section>

    <section id="graphWalkViewPanel" class="panel graph-walk-panel" hidden>
      <div class="graph-walk-head">
        <div>
          <h2>Graph Walk</h2>
          <div class="sub">Focus node + direct neighbors (Markov blanket approximation). Click a neighbor to walk and expand the next layer.</div>
        </div>
        <div class="graph-walk-actions">
          <button id="graphWalkZoomOutBtn" type="button" title="Zoom out graph">âˆ’</button>
          <button id="graphWalkZoomResetBtn" type="button" title="Reset graph zoom" aria-pressed="true">Reset View</button>
          <button id="graphWalkZoomInBtn" type="button" title="Zoom in graph">+</button>
          <button id="graphWalkSyncToFocusBtn" type="button">Reset To Focus</button>
          <button id="graphWalkClearTrailBtn" type="button">Clear Trail</button>
        </div>
      </div>
      <div id="graphWalkEmpty" class="graph-walk-empty">Select an entity or meeting focus to visualize its direct graph neighborhood.</div>
      <div class="graph-walk-breadcrumbs" id="graphWalkBreadcrumbs"></div>
      <div id="graphWalkLayout" class="graph-walk-layout" hidden>
        <div class="graph-walk-canvas-panel">
          <div class="browse-section-title">Graph Neighborhood</div>
          <div class="graph-walk-canvas-wrap">
            <svg id="graphWalkSvg" class="graph-walk-svg" viewBox="0 0 1000 640" preserveAspectRatio="xMidYMid meet" aria-label="Graph walk visualization"></svg>
          </div>
        </div>
        <div class="graph-walk-detail-panel">
          <div class="browse-section">
            <div class="browse-section-title">Focused Node</div>
            <div id="graphWalkNodeDetails" class="graph-walk-empty">No graph focus selected.</div>
          </div>
          <div class="browse-section">
            <div class="browse-section-title">Neighbors (Current Focus)</div>
            <div id="graphWalkNeighborList" class="graph-walk-list"></div>
          </div>
          <div class="browse-section">
            <div class="browse-section-title">Trail</div>
            <div id="graphWalkTrailSummary" class="graph-walk-empty">Walk the graph by clicking a neighbor node.</div>
          </div>
        </div>
      </div>
    </section>

    <section class="workspace">
      <div class="main-col">
    <div class="pane-head">
      <h2>Entity Context & Meetings</h2>
      <div class="sub">Entity exploration drives meeting context. Select an entity or meeting to progressively load related civic activity.</div>
    </div>
    <div id="operationsPlaceholder" class="related">Operations controls are available in the right pane. Use the Operations section to ingest, browse coverage, and manage cache-aware crawling.</div>
    <div id="flowJumpPanel" class="related flow-jump-sticky">
      <strong>Explore Flow</strong>: <span class="meta">Connect â†’ Evidence â†’ Pivot</span>
      <span style="margin-left:8px;"></span>
      <button type="button" class="chip" data-flow-jump-target="connect">Connect</button>
      <button type="button" class="chip" data-flow-jump-target="evidence">Evidence</button>
      <button type="button" class="chip" data-flow-jump-target="pivot">Pivot</button>
    </div>
    <section id="pinnedFocusSnapshotPanel" class="panel focus-snapshot-panel focus-snapshot-sticky" hidden>
      <div class="pane-head">
        <h2>Focus Snapshot</h2>
        <div id="pinnedFocusSnapshotSub" class="sub">Pinned entity/meeting details for the current focus.</div>
        <button id="pinnedFocusSnapshotToggle" class="focus-snapshot-toggle" type="button" aria-expanded="true">Collapse</button>
      </div>
      <div id="pinnedFocusSnapshotBody" class="focus-snapshot-body"></div>
    </section>
    <section id="operationsPanel" class="panel">
      <div id="operationsHead" class="pane-head">
        <h2>Range Ingest & Coverage</h2>
        <div class="sub">Use cached discovery when possible; run ingest when you need new coverage.</div>
      </div>
      <div class="ops-compact-note">Compact operations mode: use this panel to ingest/browse coverage. Chunk Days controls CivicWeb crawl window size; smaller values are safer for long date ranges.</div>
      <form id="queryForm">
        <div class="grid">
          <div class="col-2">
            <label for="fromDate">From Date</label>
            <input id="fromDate" name="fromDate" type="date" required />
          </div>
          <div class="col-2">
            <label for="toDate">To Date</label>
            <input id="toDate" name="toDate" type="date" required />
          </div>
          <div class="col-1">
            <label for="limit">Limit</label>
            <input id="limit" name="limit" type="number" min="1" max="1000" value="100" />
          </div>
          <div class="col-1">
            <label for="chunkDays">Chunk Days</label>
            <input id="chunkDays" name="chunkDays" type="number" min="1" max="90" value="31" />
            <div class="hint">Days per CivicWeb crawl window. Smaller = more API calls, safer for long ranges.</div>
          </div>
          <div class="col-1">
            <label for="cacheTtlMinutes">Cache TTL (minutes)</label>
            <input id="cacheTtlMinutes" name="cacheTtlMinutes" type="number" min="0" max="1440" value="60" />
            <div class="hint">Reuse recent meeting discovery lists within this time window.</div>
          </div>
          <div class="col-2">
            <label for="topic">Topic</label>
            <select id="topic" name="topic">
              <option value="">All Topics</option>
              <option value="zoning">zoning</option>
              <option value="ordinances_general">ordinances_general</option>
              <option value="public_hearings">public_hearings</option>
              <option value="schools">schools</option>
              <option value="public_safety">public_safety</option>
              <option value="enforcement">enforcement</option>
              <option value="contracts_procurement">contracts_procurement</option>
              <option value="budget_finance">budget_finance</option>
              <option value="infrastructure_transport">infrastructure_transport</option>
              <option value="urban_renewal_development">urban_renewal_development</option>
              <option value="boards_commissions">boards_commissions</option>
              <option value="licenses_permits">licenses_permits</option>
              <option value="utilities_franchise">utilities_franchise</option>
            </select>
          </div>
        </div>

        <div class="checks">
          <label><input id="crawl" type="checkbox" checked /> Crawl Historic Windows</label>
          <label><input id="storeRaw" type="checkbox" checked /> Store Raw Source Payloads</label>
          <label><input id="useRecentCache" type="checkbox" checked /> Reuse Recent Discovery Cache</label>
        </div>

        <div>
          <button id="runBtn" type="submit">Run Ingest + Filter</button>
        </div>
      </form>

      <div class="status-label">Ingest Status</div>
      <div id="ingestStatus" class="status ingest"></div>
      <div class="progress-wrap" id="progressWrap" hidden>
        <div class="progress-track"><div id="progressBar" class="progress-bar"></div></div>
      </div>

      <div id="summary" class="summary" hidden>
        <div class="kpi"><div class="k">Discovered</div><div class="v" id="kDiscovered">0</div></div>
        <div class="kpi"><div class="k">Ingested</div><div class="v" id="kIngested">0</div></div>
        <div class="kpi"><div class="k">Agenda Items Returned</div><div class="v" id="kItems">0</div></div>
      </div>
      <div id="coveragePanel" class="coverage-panel">
        <div class="entity-title">Coverage & Discovery Cache</div>
        <div id="rangeCacheStatus" class="range-cache-status">Checking cache status...</div>
        <div id="coverageStats" class="coverage-grid"></div>
        <div id="recentRanges" class="range-list"></div>
      </div>
      <div id="existingDataPanel" class="browse-panel">
        <div class="entity-title">Explore Existing Data</div>
        <div class="browse-actions">
          <button id="browseStoredMeetingsBtn" type="button">Browse Stored Meetings</button>
          <button id="refreshTopicBrowserBtn" type="button">Refresh Topic Browser</button>
        </div>
        <div class="browse-section">
          <div class="browse-section-title">Topics</div>
          <div id="topicBrowserList" class="browse-list"></div>
        </div>
        <div class="browse-section">
          <div class="browse-section-title">Stored Meetings</div>
          <div id="storedMeetingsList" class="browse-list"></div>
        </div>
      </div>
    </section>
        <section id="entityContextPanel" class="panel" hidden>
          <div class="pane-head">
            <h2 id="entityContextTitle">Focused Entity Mentions</h2>
            <div id="entityContextSub" class="sub">Quick mention preview for the currently selected entity.</div>
          </div>
          <div class="browse-section">
            <div id="entityContextBodyTitle" class="browse-section-title">Mentions / Evidence</div>
            <div id="leftEntityMentions" class="browse-list"></div>
          </div>
        </section>
        <section id="relatedEntitiesWorkspacePanel" class="exploration-panel minor">
          <div class="pane-head">
            <h2>Connections</h2>
            <div class="sub">See what connects to the current focus: related entities, related topics, and contextual meetings.</div>
          </div>
          <div class="browse-section">
            <div class="browse-section-title">Related Entities</div>
            <div id="leftRelatedEmpty" class="hint-inline">Select an entity to load related entities.</div>
            <div id="leftRelatedMount" class="exploration-grid"></div>
          </div>
          <div class="browse-section">
            <div class="browse-section-title">Related Topics</div>
            <div id="leftConnectionsTopicsMount"></div>
          </div>
          <div class="browse-section">
            <div id="connectionsMeetingsTitle" class="browse-section-title">Contextual Meetings</div>
            <div id="leftConnectionsMeetingsMount"></div>
          </div>
          <div class="browse-section" id="connectionsCandidatesSection" hidden>
            <div class="browse-section-title">Connection Candidates</div>
            <div id="leftConnectionsMatchesMount" class="exploration-grid"></div>
          </div>
        </section>
        <section id="pivotResultsWorkspacePanel" class="exploration-panel minor">
          <div class="pane-head">
            <h2>Pivot Results</h2>
            <div class="sub">Search-driven node results for selecting the next focus. Stored meetings remain a convenience path.</div>
          </div>
          <div id="leftPivotMount" class="exploration-grid"></div>
        </section>
        <section id="explorationWorkspacePanel" class="exploration-panel">
          <div class="pane-head">
            <h2 id="evidencePanelTitle">Evidence</h2>
            <div id="evidencePanelSub" class="sub">Review source snippets and supporting material for the current node or selected connection.</div>
          </div>
          <div id="leftExplorationEmpty" class="hint-inline">Use the entity search on the right or click a topic/entity chip to load contextual exploration results.</div>
          <div id="leftEdgeEvidencePanel" class="browse-section">
            <div id="leftEdgeEvidenceTitle" class="browse-section-title">Selected Edge Proof</div>
            <div id="leftEdgeEvidenceMount" class="exploration-grid"></div>
          </div>
          <div id="leftNodeEvidencePanel" class="browse-section">
            <div class="browse-section-title">Node / Search Evidence</div>
            <div id="leftExplorationMount" class="exploration-grid"></div>
            <div id="leftEvidenceMeetingMount"></div>
          </div>
        </section>
        <section id="existingDataWorkspacePanel" class="exploration-panel minor">
          <div class="pane-head">
            <h2>Explore Existing Data</h2>
            <div class="sub">Start from stored topics and meetings before running new ingest jobs. This helps users build context from what is already cached.</div>
          </div>
          <div id="leftExistingDataMount" class="exploration-grid"></div>
        </section>
        <div id="related" class="related" hidden></div>
        <div id="resultsHead" class="results-head">
          <div class="results-head-title">Evidence</div>
          <div id="resultsContextSummary" class="results-head-sub">Evidence panels stay synchronized with the active global filters and current focus.</div>
        </div>
        <section id="meetingMasterDetail" class="meeting-master-detail">
          <div id="meetingListPanel" class="meeting-list-panel">
            <div class="browse-section-title">Contextual Meetings</div>
            <div id="meetingResultsList" class="browse-list"></div>
          </div>
          <div id="meetingDetailPanel" class="meeting-detail-panel">
            <div class="meeting-detail-head">
              <div class="meeting-detail-head-main">
                <h3 id="meetingDetailTitle">Selected Meeting Detail</h3>
                <div id="meetingDetailSub" class="sub">Choose a meeting from the contextual list.</div>
              </div>
              <button id="meetingDetailToggle" class="meeting-detail-toggle" type="button" aria-expanded="true">Collapse</button>
            </div>
            <section id="results" class="results"></section>
          </div>
        </section>
      </div>
      <aside class="side-col">
        <div class="search-panel sticky">
          <div id="entityExplorerControlsBlock">
          <div class="entity-panel-header">
            <div class="entity-title">Graph Filters</div>
            <div class="sub">Set node/topic filters here. Presets may apply a topic filter or seed search; focus stays in the top strip.</div>
            <div class="facet-control-grid">
              <div class="facet-mini-panel">
                <div class="facet-mini-title">Lens Presets</div>
                <div class="lens-row">
                  <button type="button" class="lens-btn" data-quick-topic="zoning" title="Applies topic filter: zoning">Zoning</button>
                  <button type="button" class="lens-btn" data-quick-topic="schools" title="Applies topic filter: schools">Schools</button>
                  <button type="button" class="lens-btn" data-quick-topic="public_safety" title="Applies topic filter: public_safety">Public Safety</button>
                  <button type="button" class="lens-btn" data-quick-topic="enforcement" title="Applies topic filter: enforcement">Enforcement</button>
                  <button type="button" class="lens-btn" data-quick-query="development" title="Seeds entity search: development">Development</button>
                </div>
              </div>
              <div class="facet-mini-panel">
                <div class="search-type-row">
                  <div class="facet-mini-title">Node Kinds</div>
                  <div id="entityTypeFilterRow" class="search-type-filters">
                    <button type="button" class="search-type-btn active" data-entity-type-filter="">All</button>
                    <button type="button" class="search-type-btn" data-entity-type-filter="meeting">Meetings</button>
                    <button type="button" class="search-type-btn" data-entity-type-filter="document">Documents</button>
                    <button type="button" class="search-type-btn" data-entity-type-filter="person">People</button>
                    <button type="button" class="search-type-btn" data-entity-type-filter="organization">Organizations</button>
                    <button type="button" class="search-type-btn" data-entity-type-filter="address">Places</button>
                    <button type="button" class="search-type-btn" data-entity-type-filter="date">Dates</button>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div id="entitySearchControlBlock" class="filter-bar top-search-panel">
            <div class="top-search-panel-head">
              <div class="top-search-panel-title">Entity Search</div>
            </div>
            <div class="search-row">
              <div class="search-box">
                <input id="entitySearch" type="search" placeholder="Search entities, meetings, documents..." />
                <div id="entitySuggestions" class="suggestions" hidden></div>
              </div>
              <button id="entitySearchBtn" type="button">Search Entities</button>
            </div>
            <div class="hint">Search establishes node filters, then use connections/evidence to pivot.</div>
            <div id="topSearchPreview" class="top-search-preview" hidden>
              <div class="top-search-preview-head">
                <span id="topSearchPreviewTitle">Recent Focuses</span>
                <span id="topSearchPreviewCount"></span>
              </div>
              <div id="topSearchPreviewList" class="top-search-preview-list"></div>
            </div>
          </div>
          </div>
          <div id="facetViewsSidebarPanel" class="sidebar-section facet-active">
            <div class="sidebar-section-title">Facet Panels</div>
            <div class="view-tabs facet-view-tabs">
              <button id="tabSearch" type="button" class="tab-btn facet-shortcut-btn active">Scroll Up</button>
              <button id="tabTimeline" type="button" class="tab-btn facet-shortcut-btn">Open Time</button>
              <button id="tabMap" type="button" class="tab-btn facet-shortcut-btn">Open Places</button>
            </div>
            <div class="hint">Opens/highlights sections in the right panel only. Does not change node focus or selected connection.</div>
          </div>
          <div class="sidebar-scroll">
            <div class="sidebar-group-title">Entity Facets</div>
            <div class="sidebar-section collapsed" id="timelineSection"><div class="sidebar-section-title">Time (Date Entities)</div><div id="timelineResults" class="search-results"></div></div>
            <div class="sidebar-section collapsed" id="mapSection"><div class="sidebar-section-title">Places (Address Entities)</div><div id="mapResults" class="search-results"></div></div>
            <div class="sidebar-group-title">Graph Management</div>
            <div class="sidebar-section" id="explorerStatusSection">
              <div class="sidebar-section-title">Explorer Status</div>
              <div id="browseStatus" class="status browse">Discovery panel ready.</div>
            </div>
            <div class="sidebar-section collapsed" id="diagnosticsSection">
              <div class="sidebar-section-title">Graph Metadata</div>
              <div id="runtimePanel" class="runtime-panel">Graph metadata loading...</div>
            </div>
            <div class="sidebar-section operations collapsed" id="operationsSection">
              <div class="sidebar-section-title">Graph Management</div>
              <div id="operationsMount"></div>
            </div>
            <div id="searchSectionsGroup">
              <div class="sidebar-section" id="popularTopicsSection"><div class="sidebar-section-title">Popular Topics</div><div id="startupTopicsResults" class="search-results"></div></div>
              <div class="sidebar-section" id="popularEntitiesSection"><div class="sidebar-section-title">Popular Entities</div><div id="startupEntitiesResults" class="search-results"></div></div>
              <div class="sidebar-section" id="entityMatchesSection"><div class="sidebar-section-title">Node Matches</div><div id="entitySearchResults" class="search-results"></div></div>
              <div class="sidebar-section" id="meetingMatchesSection"><div class="sidebar-section-title">Stored Meeting Matches (Convenience)</div><div id="meetingSearchResults" class="search-results"></div></div>
              <div class="sidebar-section" id="contentMatchesSection"><div class="sidebar-section-title">Evidence Search Matches (Agenda & Documents)</div><div id="contentSearchResults" class="search-results"></div></div>
              <div class="sidebar-section" id="relatedEntitiesSection"><div class="sidebar-section-title">Related Entities</div><div id="entityRelatedResults" class="search-results"></div></div>
              <div class="sidebar-section collapsed" id="mentionsSection"><div class="sidebar-section-title">Mentions</div><div id="entityMentionsResults" class="search-results"></div></div>
            </div>
          </div>
        </div>
      </aside>
    </section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  <script>
    const form = document.getElementById("queryForm");
    const runBtn = document.getElementById("runBtn");
    const ingestStatusEl = document.getElementById("ingestStatus");
    const resultsEl = document.getElementById("results");
    const resultsHeadEl = document.getElementById("resultsHead");
    const meetingMasterDetailEl = document.getElementById("meetingMasterDetail");
    const meetingListPanelEl = document.getElementById("meetingListPanel");
    const meetingDetailPanelEl = document.getElementById("meetingDetailPanel");
    const meetingResultsListEl = document.getElementById("meetingResultsList");
    const meetingDetailTitleEl = document.getElementById("meetingDetailTitle");
    const meetingDetailSubEl = document.getElementById("meetingDetailSub");
    const meetingDetailToggleEl = document.getElementById("meetingDetailToggle");
    const summaryEl = document.getElementById("summary");
    const relatedEl = document.getElementById("related");
    const progressWrap = document.getElementById("progressWrap");
    const progressBar = document.getElementById("progressBar");
    const entitySearchEl = document.getElementById("entitySearch");
    const entitySearchBtn = document.getElementById("entitySearchBtn");
    const entityTypeFilterRowEl = document.getElementById("entityTypeFilterRow");
    const entitySearchResultsEl = document.getElementById("entitySearchResults");
    const contentSearchResultsEl = document.getElementById("contentSearchResults");
    const meetingSearchResultsEl = document.getElementById("meetingSearchResults");
    const entityRelatedResultsEl = document.getElementById("entityRelatedResults");
    const entityMentionsResultsEl = document.getElementById("entityMentionsResults");
    const startupTopicsResultsEl = document.getElementById("startupTopicsResults");
    const startupEntitiesResultsEl = document.getElementById("startupEntitiesResults");
    const timelineResultsEl = document.getElementById("timelineResults");
    const mapResultsEl = document.getElementById("mapResults");
    const timelineSectionEl = document.getElementById("timelineSection");
    const mapSectionEl = document.getElementById("mapSection");
    const runtimePanelEl = document.getElementById("runtimePanel");
    const browseStatusEl = document.getElementById("browseStatus");
    const entitySuggestionsEl = document.getElementById("entitySuggestions");
    const tabSearchEl = document.getElementById("tabSearch");
    const tabTimelineEl = document.getElementById("tabTimeline");
    const tabMapEl = document.getElementById("tabMap");
    const rangeCacheStatusEl = document.getElementById("rangeCacheStatus");
    const coverageStatsEl = document.getElementById("coverageStats");
    const recentRangesEl = document.getElementById("recentRanges");
    const browseStoredMeetingsBtn = document.getElementById("browseStoredMeetingsBtn");
    const refreshTopicBrowserBtn = document.getElementById("refreshTopicBrowserBtn");
    const storedMeetingsListEl = document.getElementById("storedMeetingsList");
    const topicBrowserListEl = document.getElementById("topicBrowserList");
    const mainColEl = document.querySelector(".main-col");
    const operationsPanelEl = document.getElementById("operationsPanel");
    const operationsHeadEl = document.getElementById("operationsHead");
    const operationsMountEl = document.getElementById("operationsMount");
    const operationsPlaceholderEl = document.getElementById("operationsPlaceholder");
    const popularTopicsSectionEl = document.getElementById("popularTopicsSection");
    const popularEntitiesSectionEl = document.getElementById("popularEntitiesSection");
    const existingDataWorkspacePanelEl = document.getElementById("existingDataWorkspacePanel");
    const existingDataPanelEl = document.getElementById("existingDataPanel");
    const entityContextPanelEl = document.getElementById("entityContextPanel");
    const entityContextSummaryEl = document.getElementById("entityContextSummary");
    const leftEntityMentionsEl = document.getElementById("leftEntityMentions");
    const leftEntityRelatedEl = document.getElementById("leftEntityRelated");
    const explorationWorkspacePanelEl = document.getElementById("explorationWorkspacePanel");
    const leftExplorationMountEl = document.getElementById("leftExplorationMount");
    const leftExplorationEmptyEl = document.getElementById("leftExplorationEmpty");
    const entityMatchesSectionEl = document.getElementById("entityMatchesSection");
    const meetingMatchesSectionEl = document.getElementById("meetingMatchesSection");
    const contentMatchesSectionEl = document.getElementById("contentMatchesSection");
    const relatedEntitiesSectionEl = document.getElementById("relatedEntitiesSection");
    const mentionsSectionEl = document.getElementById("mentionsSection");
    const mentionsSectionTitleEl = mentionsSectionEl ? mentionsSectionEl.querySelector(".sidebar-section-title") : null;
    const contentMatchesSectionTitleEl = contentMatchesSectionEl ? contentMatchesSectionEl.querySelector(".sidebar-section-title") : null;
    const resultsContextSummaryEl = document.getElementById("resultsContextSummary");
    const activeFilterChipsEl = document.getElementById("activeFilterChips");
    const clearAllFiltersBtn = document.getElementById("clearAllFiltersBtn");
    const topFilterControlsMountEl = document.getElementById("topFilterControlsMount");
    const topFilterMountEl = document.getElementById("topFilterMount");
    const topSearchMountEl = document.getElementById("topSearchMount");
    const topExplorerControlsPanelEl = document.getElementById("topExplorerControlsPanel");
    const workbenchViewBtnEl = document.getElementById("workbenchViewBtn");
    const graphWalkViewBtnEl = document.getElementById("graphWalkViewBtn");
    const topExplorerCompactToggleEl = document.getElementById("topExplorerCompactToggle");
    const graphWalkViewPanelEl = document.getElementById("graphWalkViewPanel");
    const graphWalkEmptyEl = document.getElementById("graphWalkEmpty");
    const graphWalkLayoutEl = document.getElementById("graphWalkLayout");
    const graphWalkSvgEl = document.getElementById("graphWalkSvg");
    const graphWalkBreadcrumbsEl = document.getElementById("graphWalkBreadcrumbs");
    const graphWalkNodeDetailsEl = document.getElementById("graphWalkNodeDetails");
    const graphWalkNeighborListEl = document.getElementById("graphWalkNeighborList");
    const graphWalkTrailSummaryEl = document.getElementById("graphWalkTrailSummary");
    const graphWalkZoomOutBtnEl = document.getElementById("graphWalkZoomOutBtn");
    const graphWalkZoomResetBtnEl = document.getElementById("graphWalkZoomResetBtn");
    const graphWalkZoomInBtnEl = document.getElementById("graphWalkZoomInBtn");
    const graphWalkSyncToFocusBtnEl = document.getElementById("graphWalkSyncToFocusBtn");
    const graphWalkClearTrailBtnEl = document.getElementById("graphWalkClearTrailBtn");
    const filterBarPanelEl = document.getElementById("filterBarPanel");
    const entitySearchControlBlockEl = document.getElementById("entitySearchControlBlock");
    const topSearchPreviewEl = document.getElementById("topSearchPreview");
    const topSearchPreviewTitleEl = document.getElementById("topSearchPreviewTitle");
    const topSearchPreviewCountEl = document.getElementById("topSearchPreviewCount");
    const topSearchPreviewListEl = document.getElementById("topSearchPreviewList");
    const topFocusPanelEl = document.getElementById("topFocusPanel");
    const entityExplorerControlsBlockEl = document.getElementById("entityExplorerControlsBlock");
    const focusDetailsCardEl = document.getElementById("focusDetailsCard");
    const topSelectedConnectionPanelEl = document.getElementById("topSelectedConnectionPanel");
    const topSelectedConnectionSubEl = document.getElementById("topSelectedConnectionSub");
    const topSelectedConnectionStatsEl = document.getElementById("topSelectedConnectionStats");
    const backToFocusNodeBtn = document.getElementById("backToFocusNodeBtn");
    const clearSelectedConnectionBtn = document.getElementById("clearSelectedConnectionBtn");
    const clearCurrentFocusBtn = document.getElementById("clearCurrentFocusBtn");
    const entityContextTitleEl = document.getElementById("entityContextTitle");
    const entityContextSubEl = document.getElementById("entityContextSub");
    const entityContextBodyTitleEl = document.getElementById("entityContextBodyTitle");
    const relatedEntitiesWorkspacePanelEl = document.getElementById("relatedEntitiesWorkspacePanel");
    const leftRelatedMountEl = document.getElementById("leftRelatedMount");
    const leftRelatedEmptyEl = document.getElementById("leftRelatedEmpty");
    const leftConnectionsTopicsMountEl = document.getElementById("leftConnectionsTopicsMount");
    const leftConnectionsMeetingsMountEl = document.getElementById("leftConnectionsMeetingsMount");
    const leftConnectionsMatchesMountEl = document.getElementById("leftConnectionsMatchesMount");
    const pivotResultsWorkspacePanelEl = document.getElementById("pivotResultsWorkspacePanel");
    const leftPivotMountEl = document.getElementById("leftPivotMount");
    const connectionsMeetingsTitleEl = document.getElementById("connectionsMeetingsTitle");
    const leftEvidenceMeetingMountEl = document.getElementById("leftEvidenceMeetingMount");
    const leftEdgeEvidencePanelEl = document.getElementById("leftEdgeEvidencePanel");
    const leftEdgeEvidenceTitleEl = document.getElementById("leftEdgeEvidenceTitle");
    const leftEdgeEvidenceMountEl = document.getElementById("leftEdgeEvidenceMount");
    const leftNodeEvidencePanelEl = document.getElementById("leftNodeEvidencePanel");
    const leftExistingDataMountEl = document.getElementById("leftExistingDataMount");
    const evidencePanelTitleEl = document.getElementById("evidencePanelTitle");
    const evidencePanelSubEl = document.getElementById("evidencePanelSub");
    const flowJumpPanelEl = document.getElementById("flowJumpPanel");
    const pinnedFocusSnapshotPanelEl = document.getElementById("pinnedFocusSnapshotPanel");
    const pinnedFocusSnapshotSubEl = document.getElementById("pinnedFocusSnapshotSub");
    const pinnedFocusSnapshotBodyEl = document.getElementById("pinnedFocusSnapshotBody");
    const pinnedFocusSnapshotToggleEl = document.getElementById("pinnedFocusSnapshotToggle");

    const fromDate = document.getElementById("fromDate");
    const toDate = document.getElementById("toDate");
    const topicEl = document.getElementById("topic");
    fromDate.value = fromDate.value || "2026-01-01";
    toDate.value = toDate.value || new Date().toISOString().slice(0, 10);

    let lastMeetingResults = [];
    let lastIngestSummary = null;
    let activeSidebarView = "search";
    let suggestTimer = null;
    let coverageTimer = null;
    let selectedStoredMeetingId = null;
    let selectedContextMeetingId = null;
    let selectedEntityContext = { entityId: null, label: "", entityType: "", bindings: [], kindMetadata: {} };
    let selectedMeetingContext = null;
    let selectedConnectionContext = null;
    let lastEntityMentionsEntity = null;
    let lastEntitySearchRows = [];
    let lastEntityRelatedRows = [];
    let lastConnectionFocus = null;
    let meetingDetailCollapsed = false;
    let pinnedFocusSnapshotCollapsed = false;
    let focusSnapshotMeetingPreviewCollapsed = false;
    let topExplorerCompact = false;
    let recentFocusHistory = [];
    let activeMainView = "workbench";
    let graphWalkFocusEntity = null;
    let graphWalkTrail = [];
    let graphWalkExpandedNodeIds = new Set();
    let graphWalkNodeMap = new Map();
    let graphWalkEdges = [];
    let graphWalkLoading = false;
    let graphWalkPreserveTrailOnNextFocusSync = false;
    let graphWalkD3State = {
      ready: false,
      zoomBehavior: null,
      svg: null,
      root: null,
      edgeLayer: null,
      edgeLabelLayer: null,
      nodeLayer: null,
      currentTransform: null,
    };
    const globalFilters = {
      topic: "",
      entityQuery: "",
      entityType: "",
      meetingId: null,
    };

    function pushRecentFocus(entry) {
      const kind = String(entry?.kind || "").trim();
      const id = Number(entry?.id || 0);
      const label = String(entry?.label || "").trim();
      if (!kind || !id || !label) return;
      const key = `${kind}:${id}`;
      const next = {
        key,
        kind,
        id,
        label,
        entityType: String(entry?.entityType || "").trim(),
        normalized: String(entry?.normalized || "").trim(),
        bindings: Array.isArray(entry?.bindings) ? entry.bindings : [],
        kindMetadata: (entry?.kindMetadata && typeof entry.kindMetadata === "object") ? entry.kindMetadata : {},
      };
      recentFocusHistory = [next, ...recentFocusHistory.filter((r) => r.key !== key)].slice(0, 8);
      renderTopSearchPreview(lastEntitySearchRows);
    }

    function currentFocusHistoryKey() {
      if (selectedMeetingContext?.meetingId) return `meeting:${Number(selectedMeetingContext.meetingId)}`;
      if (selectedEntityContext?.entityId) return `entity:${Number(selectedEntityContext.entityId)}`;
      return "";
    }

    function setMainViewMode(view) {
      activeMainView = view === "graph" ? "graph" : "workbench";
      if (workbenchViewBtnEl instanceof HTMLElement) {
        workbenchViewBtnEl.classList.toggle("active", activeMainView === "workbench");
        workbenchViewBtnEl.setAttribute("aria-pressed", String(activeMainView === "workbench"));
      }
      if (graphWalkViewBtnEl instanceof HTMLElement) {
        graphWalkViewBtnEl.classList.toggle("active", activeMainView === "graph");
        graphWalkViewBtnEl.setAttribute("aria-pressed", String(activeMainView === "graph"));
      }
      const workspaceEl = document.querySelector(".workspace");
      if (workspaceEl instanceof HTMLElement) workspaceEl.hidden = activeMainView !== "workbench";
      if (graphWalkViewPanelEl instanceof HTMLElement) graphWalkViewPanelEl.hidden = activeMainView !== "graph";
      if (activeMainView === "graph") {
        void syncGraphWalkFromCurrentFocus({ forceReset: graphWalkTrail.length === 0 });
      }
      syncWorkspaceHeight();
    }

    function clearGraphWalkState() {
      graphWalkFocusEntity = null;
      graphWalkTrail = [];
      graphWalkExpandedNodeIds = new Set();
      graphWalkNodeMap = new Map();
      graphWalkEdges = [];
      graphWalkPreserveTrailOnNextFocusSync = false;
      renderGraphWalk();
    }

    function currentGraphFocusSourceNode() {
      if (lastConnectionFocus && lastConnectionFocus.entityId) {
        return {
          entityId: Number(lastConnectionFocus.entityId),
          label: String(lastConnectionFocus.label || `Entity ${lastConnectionFocus.entityId}`),
          entityType: String(lastConnectionFocus.entityType || "").trim(),
          bindings: Array.isArray(lastConnectionFocus.bindings) ? lastConnectionFocus.bindings : [],
          kindMetadata: (lastConnectionFocus.kindMetadata && typeof lastConnectionFocus.kindMetadata === "object")
            ? lastConnectionFocus.kindMetadata
            : {},
        };
      }
      if (selectedEntityContext && selectedEntityContext.entityId) {
        return {
          entityId: Number(selectedEntityContext.entityId),
          label: String(selectedEntityContext.label || `Entity ${selectedEntityContext.entityId}`),
          entityType: String(selectedEntityContext.entityType || "").trim(),
          bindings: Array.isArray(selectedEntityContext.bindings) ? selectedEntityContext.bindings : [],
          kindMetadata: (selectedEntityContext.kindMetadata && typeof selectedEntityContext.kindMetadata === "object")
            ? selectedEntityContext.kindMetadata
            : {},
        };
      }
      return null;
    }

    function graphWalkNodeKey(entityId) {
      return `n:${Number(entityId)}`;
    }

    function graphWalkEdgeKey(fromEntityId, toEntityId, relationType) {
      return `${Number(fromEntityId)}>${Number(toEntityId)}:${String(relationType || "")}`;
    }

    function graphWalkStoreNode(node) {
      const entityId = Number(node?.entityId || 0);
      if (!Number.isFinite(entityId) || entityId <= 0) return null;
      const existing = graphWalkNodeMap.get(entityId) || {};
      const nextLoadedNeighborCountRaw = (node && Object.prototype.hasOwnProperty.call(node, "loadedNeighborCount"))
        ? Number(node.loadedNeighborCount)
        : Number(existing.loadedNeighborCount);
      const next = {
        entityId,
        label: String(node?.label || existing.label || `Entity ${entityId}`),
        entityType: String(node?.entityType || existing.entityType || "").trim(),
        normalized: String(node?.normalized || existing.normalized || "").trim(),
        bindings: Array.isArray(node?.bindings) ? node.bindings : (Array.isArray(existing.bindings) ? existing.bindings : []),
        kindMetadata: (node?.kindMetadata && typeof node.kindMetadata === "object")
          ? node.kindMetadata
          : ((existing.kindMetadata && typeof existing.kindMetadata === "object") ? existing.kindMetadata : {}),
        loadedNeighborCount: Number.isFinite(nextLoadedNeighborCountRaw) && nextLoadedNeighborCountRaw >= 0
          ? nextLoadedNeighborCountRaw
          : 0,
      };
      graphWalkNodeMap.set(entityId, next);
      return next;
    }

    function graphWalkNodeFromConnectionRow(row) {
      return graphWalkStoreNode({
        entityId: Number(row.entity_id),
        label: row.display_value || `Entity ${row.entity_id}`,
        entityType: row.entity_type || "",
        normalized: row.normalized_value || "",
        bindings: row.bindings || [],
        kindMetadata: row.kind_metadata || {},
      });
    }

    async function fetchEntityConnectionsForGraph(entityId, limit = 25) {
      const res = await fetch(`/entities/${entityId}/connections?limit=${Number(limit || 25)}`);
      if (!res.ok) throw new Error(`Graph connections failed (${res.status})`);
      return await res.json();
    }

    function graphWalkUpsertEdgesFromRows(sourceNode, rows) {
      const sourceId = Number(sourceNode?.entityId || 0);
      if (!Number.isFinite(sourceId) || sourceId <= 0) return;
      const edgeMap = new Map(graphWalkEdges.map((e) => [graphWalkEdgeKey(e.fromEntityId, e.toEntityId, e.relationType), e]));
      for (const row of rows || []) {
        const otherId = Number(row.entity_id || 0);
        if (!Number.isFinite(otherId) || otherId <= 0) continue;
        const direction = String(row.direction || "outgoing");
        const relationType = String(row.relation_type || "");
        const fromEntityId = direction === "outgoing" ? sourceId : otherId;
        const toEntityId = direction === "outgoing" ? otherId : sourceId;
        const key = graphWalkEdgeKey(fromEntityId, toEntityId, relationType);
        const next = {
          fromEntityId,
          toEntityId,
          relationType,
          directionFromSource: direction,
          sourceEntityId: sourceId,
          edgeCount: Number(row.edge_count || 0),
          evidenceCount: Number(row.evidence_count || 0),
          sharedMeetingCount: Number(row.shared_meeting_count || 0),
        };
        edgeMap.set(key, next);
      }
      graphWalkEdges = Array.from(edgeMap.values());
    }

    function graphWalkEnsureTrail(entityNode, { resetTrail = false } = {}) {
      if (!entityNode || !entityNode.entityId) return;
      const entityId = Number(entityNode.entityId);
      if (resetTrail || !graphWalkTrail.length) {
        graphWalkTrail = [entityId];
        return;
      }
      if (Number(graphWalkTrail[graphWalkTrail.length - 1]) === entityId) return;
      const existingIdx = graphWalkTrail.findIndex((id) => Number(id) === entityId);
      if (existingIdx >= 0) {
        graphWalkTrail = graphWalkTrail.slice(0, existingIdx + 1);
        return;
      }
      graphWalkTrail = [...graphWalkTrail, entityId].slice(-12);
    }

    async function graphWalkExpandNodeNeighborhood(entityNode, { resetTrail = false } = {}) {
      const storedNode = graphWalkStoreNode(entityNode);
      if (!storedNode) return;
      graphWalkFocusEntity = storedNode;
      graphWalkEnsureTrail(storedNode, { resetTrail });
      graphWalkLoading = true;
      renderGraphWalk();
      try {
        const rows = await fetchEntityConnectionsForGraph(storedNode.entityId, 24);
        storedNode.loadedNeighborCount = Array.isArray(rows) ? rows.length : 0;
        for (const row of rows) graphWalkNodeFromConnectionRow(row);
        graphWalkUpsertEdgesFromRows(storedNode, rows);
        graphWalkExpandedNodeIds.add(Number(storedNode.entityId));
      } catch (err) {
        if (graphWalkNodeDetailsEl instanceof HTMLElement) {
          graphWalkNodeDetailsEl.innerHTML = `<div class="meta">${escapeHtml(err.message || "Unable to load graph neighborhood.")}</div>`;
        }
      } finally {
        graphWalkLoading = false;
        renderGraphWalk();
      }
    }

    function graphWalkCurrentSelectedEdgeKey() {
      if (!selectedConnectionContext || !lastConnectionFocus?.entityId || !selectedConnectionContext.toEntityId) return "";
      const fromEntityId = selectedConnectionContext.direction === "outgoing"
        ? Number(lastConnectionFocus.entityId)
        : Number(selectedConnectionContext.toEntityId);
      const toEntityId = selectedConnectionContext.direction === "outgoing"
        ? Number(selectedConnectionContext.toEntityId)
        : Number(lastConnectionFocus.entityId);
      return graphWalkEdgeKey(fromEntityId, toEntityId, selectedConnectionContext.relationType || "");
    }

    function graphWalkKindLabel(entityType) {
      const t = String(entityType || "").trim().toLowerCase();
      if (!t) return "entity";
      return t.replace(/_/g, " ");
    }

    function graphWalkShortLabel(label, maxLen = 24) {
      const text = String(label || "").trim();
      if (text.length <= maxLen) return text;
      return `${text.slice(0, maxLen - 1)}â€¦`;
    }

    function graphWalkNodeSummary(node) {
      const bits = [];
      const kindMeta = (node?.kindMetadata && typeof node.kindMetadata === "object") ? node.kindMetadata : {};
      if (node?.entityType === "meeting") {
        const name = String(kindMeta.name || "").trim();
        const location = String(kindMeta.location || "").trim();
        const time = String(kindMeta.time || "").trim();
        if (name) bits.push(name);
        if (location) bits.push(location);
        if (time) bits.push(time);
      } else if (node?.entityType === "address") {
        if (kindMeta.city) bits.push(kindMeta.city);
        if (kindMeta.state) bits.push(kindMeta.state);
        if (kindMeta.zip_code) bits.push(kindMeta.zip_code);
      } else if (node?.entityType === "date") {
        if (kindMeta.normalized_date) bits.push(kindMeta.normalized_date);
      } else {
        if (kindMeta.primary_name) bits.push(kindMeta.primary_name);
      }
      return bits.filter(Boolean).join(" â€¢ ");
    }

    function graphWalkNeighborRowsForFocus() {
      if (!graphWalkFocusEntity?.entityId) return [];
      const focusId = Number(graphWalkFocusEntity.entityId);
      const rows = [];
      for (const edge of graphWalkEdges) {
        if (Number(edge.fromEntityId) !== focusId && Number(edge.toEntityId) !== focusId) continue;
        const outgoing = Number(edge.fromEntityId) === focusId;
        const otherId = outgoing ? Number(edge.toEntityId) : Number(edge.fromEntityId);
        const node = graphWalkNodeMap.get(otherId);
        if (!node) continue;
        const kindFilter = String(globalFilters.entityType || "").trim().toLowerCase();
        if (kindFilter && String(node.entityType || "").trim().toLowerCase() !== kindFilter) continue;
        rows.push({
          entityId: otherId,
          label: node.label,
          entityType: node.entityType,
          bindings: node.bindings || [],
          kindMetadata: node.kindMetadata || {},
          relationType: edge.relationType,
          direction: outgoing ? "outgoing" : "incoming",
          edgeCount: Number(edge.edgeCount || 0),
          evidenceCount: Number(edge.evidenceCount || 0),
          sharedMeetingCount: Number(edge.sharedMeetingCount || 0),
        });
      }
      rows.sort((a, b) => (Number(b.evidenceCount || 0) - Number(a.evidenceCount || 0)) || String(a.label || "").localeCompare(String(b.label || "")));
      return rows;
    }

    function graphWalkKnownNeighborCount(entityId) {
      const id = Number(entityId || 0);
      if (!Number.isFinite(id) || id <= 0) return 0;
      const node = graphWalkNodeMap.get(id);
      const explicit = Number(node?.loadedNeighborCount || 0);
      if (Number.isFinite(explicit) && explicit > 0) return explicit;
      let count = 0;
      for (const edge of graphWalkEdges) {
        if (Number(edge.fromEntityId) === id || Number(edge.toEntityId) === id) count += 1;
      }
      return count;
    }

    function graphWalkNodeRadius(entityId, focusId) {
      const id = Number(entityId || 0);
      const isFocus = Number(id) === Number(focusId || 0);
      const degree = Math.max(0, graphWalkKnownNeighborCount(id));
      const base = isFocus ? 24 : 16;
      const maxExtra = isFocus ? 16 : 14;
      const extra = Math.min(maxExtra, Math.sqrt(degree) * 2.6);
      return Math.round((base + extra) * 10) / 10;
    }

    function graphWalkEdgeStrokeWidth(edge, selectedEdgeKey = "") {
      if (!edge) return 1.5;
      const key = edge.key || graphWalkEdgeKey(edge.fromEntityId, edge.toEntityId, edge.relationType);
      const evidenceCount = Number(edge.evidenceCount || 0);
      const edgeCount = Number(edge.edgeCount || 0);
      const strength = Math.max(1, evidenceCount, edgeCount * 1.5);
      let width = 1 + Math.min(7.5, Math.sqrt(strength) * 0.7);
      if (selectedEdgeKey && key === selectedEdgeKey) width += 1.1;
      return Math.round(width * 10) / 10;
    }

    async function graphWalkSelectConnectionForNode(entityId) {
      const otherId = Number(entityId || 0);
      const focusId = Number(graphWalkFocusEntity?.entityId || 0);
      if (!Number.isFinite(otherId) || otherId <= 0) return false;
      if (!Number.isFinite(focusId) || focusId <= 0) return false;
      if (otherId === focusId) return false;
      if (!lastConnectionFocus || Number(lastConnectionFocus.entityId || 0) !== focusId) return false;
      const relationMatches = (lastEntityRelatedRows || []).filter((row) => Number(row.entity_id || 0) === otherId);
      if (!relationMatches.length) return false;
      relationMatches.sort((a, b) =>
        (Number(b.evidence_count || 0) - Number(a.evidence_count || 0)) ||
        (Number(b.edge_count || 0) - Number(a.edge_count || 0)) ||
        String(a.relation_type || "").localeCompare(String(b.relation_type || ""))
      );
      const best = relationMatches[0];
      await loadConnectionEvidence(otherId, String(best.relation_type || ""), String(best.direction || "outgoing"));
      return true;
    }

    function graphWalkD3Available() {
      return Boolean(window.d3 && graphWalkSvgEl instanceof SVGElement);
    }

    function setGraphWalkZoomResetPressedState() {
      if (!(graphWalkZoomResetBtnEl instanceof HTMLElement)) return;
      const t = graphWalkD3State.currentTransform;
      const isReset = !t || (
        Math.abs(Number(t.k || 1) - 1) < 0.001 &&
        Math.abs(Number(t.x || 0)) < 0.5 &&
        Math.abs(Number(t.y || 0)) < 0.5
      );
      graphWalkZoomResetBtnEl.setAttribute("aria-pressed", String(isReset));
    }

    function ensureGraphWalkD3Scene() {
      if (!graphWalkD3Available()) return false;
      if (graphWalkD3State.ready && graphWalkD3State.svg && graphWalkD3State.root) return true;
      const d3 = window.d3;
      const svg = d3.select(graphWalkSvgEl);
      svg.selectAll("*").remove();
      const root = svg.append("g").attr("class", "graph-walk-d3-root");
      const edgeLayer = root.append("g").attr("class", "graph-walk-d3-edges");
      const edgeLabelLayer = root.append("g").attr("class", "graph-walk-d3-edge-labels");
      const nodeLayer = root.append("g").attr("class", "graph-walk-d3-nodes");
      const zoomBehavior = d3.zoom()
        .scaleExtent([0.35, 4.5])
        .on("zoom", (event) => {
          root.attr("transform", event.transform);
          graphWalkD3State.currentTransform = event.transform;
          setGraphWalkZoomResetPressedState();
        });
      svg.call(zoomBehavior);
      svg.on("dblclick.zoom", null);
      graphWalkD3State = {
        ready: true,
        zoomBehavior,
        svg,
        root,
        edgeLayer,
        edgeLabelLayer,
        nodeLayer,
        currentTransform: d3.zoomIdentity,
      };
      setGraphWalkZoomResetPressedState();
      return true;
    }

    function graphWalkZoomBy(factor = 1) {
      if (!graphWalkD3Available() || !ensureGraphWalkD3Scene()) return;
      const d3 = window.d3;
      const svg = graphWalkD3State.svg;
      const width = graphWalkSvgEl.viewBox?.baseVal?.width || 1000;
      const height = graphWalkSvgEl.viewBox?.baseVal?.height || 640;
      svg.transition().duration(180).call(
        graphWalkD3State.zoomBehavior.scaleBy,
        Number(factor || 1),
        [width / 2, height / 2]
      );
    }

    function graphWalkResetZoom({ immediate = false } = {}) {
      if (!graphWalkD3Available() || !ensureGraphWalkD3Scene()) return;
      const d3 = window.d3;
      const selection = immediate ? graphWalkD3State.svg : graphWalkD3State.svg.transition().duration(180);
      selection.call(graphWalkD3State.zoomBehavior.transform, d3.zoomIdentity);
    }

    function renderGraphWalkWithD3(nodes, edges, { focusId, selectedEdgeKey }) {
      if (!ensureGraphWalkD3Scene()) return false;
      const d3 = window.d3;
      const width = graphWalkSvgEl.viewBox?.baseVal?.width || 1000;
      const height = graphWalkSvgEl.viewBox?.baseVal?.height || 640;
      const nodesById = new Map(nodes.map((n) => [Number(n.id), n]));
      const edgeData = (edges || []).map((edge) => {
        const source = nodesById.get(Number(edge.fromEntityId));
        const target = nodesById.get(Number(edge.toEntityId));
        if (!source || !target) return null;
        return {
          ...edge,
          key: graphWalkEdgeKey(edge.fromEntityId, edge.toEntityId, edge.relationType),
          source,
          target,
        };
      }).filter(Boolean);

      const clampX = (x) => Math.max(52, Math.min(width - 52, Number(x || 0)));
      const clampY = (y) => Math.max(52, Math.min(height - 52, Number(y || 0)));

      const updateEdgeGeometry = () => {
        graphWalkD3State.edgeLayer.selectAll("line.graph-edge")
          .attr("x1", (d) => d.source.x)
          .attr("y1", (d) => d.source.y)
          .attr("x2", (d) => d.target.x)
          .attr("y2", (d) => d.target.y)
          .attr("stroke-width", (d) => graphWalkEdgeStrokeWidth(d, selectedEdgeKey))
          .classed("selected", (d) => d.key === selectedEdgeKey);

        graphWalkD3State.edgeLabelLayer.selectAll("text.graph-edge-label")
          .attr("x", (d) => Math.round((d.source.x + d.target.x) / 2))
          .attr("y", (d) => Math.round((d.source.y + d.target.y) / 2) - 4)
          .text((d) => `${d.relationType} (${Number(d.evidenceCount || 0)})`);

        graphWalkD3State.nodeLayer.selectAll("g.graph-node")
          .attr("transform", (d) => `translate(${Math.round(d.x)},${Math.round(d.y)})`)
          .classed("focus", (d) => Number(d.id) === Number(focusId))
          .classed("trail", (d) => Array.isArray(graphWalkTrail) && graphWalkTrail.map(Number).includes(Number(d.id)))
          .classed("selected-connection", (d) => Boolean(selectedConnectionContext && Number(selectedConnectionContext.toEntityId || 0) === Number(d.id)));
      };

      const dragBehavior = d3.drag()
        .on("start", function() { d3.select(this).raise(); })
        .on("drag", (event, d) => {
          d.x = clampX(event.x);
          d.y = clampY(event.y);
          if (d.nodeRef && typeof d.nodeRef === "object") {
            d.nodeRef.gx = d.x;
            d.nodeRef.gy = d.y;
          }
          updateEdgeGeometry();
        });

      const edgeSel = graphWalkD3State.edgeLayer.selectAll("line.graph-edge")
        .data(edgeData, (d) => d.key);
      edgeSel.exit().remove();
      edgeSel.enter()
        .append("line")
        .attr("class", "graph-edge");

      const edgeLabelSel = graphWalkD3State.edgeLabelLayer.selectAll("text.graph-edge-label")
        .data(edgeData, (d) => d.key);
      edgeLabelSel.exit().remove();
      edgeLabelSel.enter()
        .append("text")
        .attr("class", "graph-edge-label")
        .attr("text-anchor", "middle");

      const nodeSel = graphWalkD3State.nodeLayer.selectAll("g.graph-node")
        .data(nodes, (d) => Number(d.id));
      nodeSel.exit().remove();
      const nodeEnter = nodeSel.enter()
        .append("g")
        .attr("class", "graph-node")
        .attr("data-graph-node-id", (d) => Number(d.id))
        .style("cursor", "pointer");
      nodeEnter.append("circle");
      nodeEnter.append("text")
        .attr("class", "graph-node-label")
        .attr("text-anchor", "middle")
        .attr("y", -2);
      nodeEnter.append("text")
        .attr("class", "graph-node-sub")
        .attr("text-anchor", "middle");

      const nodeMerge = nodeEnter.merge(nodeSel);
      nodeMerge.call(dragBehavior);
      nodeMerge.on("click", async (event, d) => {
        event.preventDefault();
        event.stopPropagation();
        const entityId = Number(d?.id || 0);
        if (Number.isFinite(entityId) && entityId > 0) {
          const selectedAsConnection = await graphWalkSelectConnectionForNode(entityId);
          if (!selectedAsConnection) {
            void graphWalkFocusNodeById(entityId);
          }
        }
      });
      nodeMerge.select("circle")
        .attr("r", (d) => graphWalkNodeRadius(d.id, focusId));
      nodeMerge.select("text.graph-node-label")
        .text((d) => graphWalkShortLabel(d.label, Number(d.id) === Number(focusId) ? 28 : 20));
      nodeMerge.select("text.graph-node-sub")
        .attr("y", (d) => graphWalkNodeRadius(d.id, focusId) + 14)
        .text((d) => graphWalkKindLabel(d.entityType));

      updateEdgeGeometry();
      return true;
    }

    function renderGraphWalk() {
      if (!(graphWalkViewPanelEl instanceof HTMLElement)) return;
      const hasFocus = Boolean(graphWalkFocusEntity && graphWalkFocusEntity.entityId);
      if (graphWalkEmptyEl instanceof HTMLElement) graphWalkEmptyEl.hidden = hasFocus;
      if (graphWalkLayoutEl instanceof HTMLElement) graphWalkLayoutEl.hidden = !hasFocus;
      if (!hasFocus) {
        if (graphWalkBreadcrumbsEl instanceof HTMLElement) graphWalkBreadcrumbsEl.innerHTML = "";
        if (graphWalkNeighborListEl instanceof HTMLElement) graphWalkNeighborListEl.innerHTML = "";
        if (graphWalkTrailSummaryEl instanceof HTMLElement) graphWalkTrailSummaryEl.textContent = "Walk the graph by clicking a neighbor node.";
        if (graphWalkSvgEl instanceof SVGElement) graphWalkSvgEl.innerHTML = "";
        return;
      }

      const focusId = Number(graphWalkFocusEntity.entityId);
      const selectedEdgeKey = graphWalkCurrentSelectedEdgeKey();
      const trailIds = (graphWalkTrail.length ? graphWalkTrail : [focusId]).map(Number);
      const nodeIdsToRender = new Set(trailIds);
      for (const edge of graphWalkEdges) {
        if (graphWalkExpandedNodeIds.has(Number(edge.fromEntityId)) || graphWalkExpandedNodeIds.has(Number(edge.toEntityId))) {
          nodeIdsToRender.add(Number(edge.fromEntityId));
          nodeIdsToRender.add(Number(edge.toEntityId));
        }
      }
      if (!nodeIdsToRender.has(focusId)) nodeIdsToRender.add(focusId);
      const kindFilter = String(globalFilters.entityType || "").trim().toLowerCase();
      if (kindFilter) {
        for (const id of Array.from(nodeIdsToRender)) {
          if (Number(id) === focusId) continue; // keep the anchor focus visible
          const node = graphWalkNodeMap.get(Number(id));
          const entityType = String(node?.entityType || "").trim().toLowerCase();
          if (entityType !== kindFilter) nodeIdsToRender.delete(Number(id));
        }
      }

      const w = 1000;
      const h = 640;
      const positions = new Map();
      const anchors = trailIds.filter((id) => nodeIdsToRender.has(id));
      const anchorCount = anchors.length || 1;
      const xMargin = 120;
      const yCenter = Math.round(h * 0.52);
      for (let i = 0; i < anchorCount; i++) {
        const id = anchors[i] ?? focusId;
        const x = anchorCount === 1
          ? Math.round(w / 2)
          : Math.round(xMargin + ((w - xMargin * 2) * i) / Math.max(1, anchorCount - 1));
        positions.set(Number(id), { x, y: yCenter });
      }
      const placed = new Set(Array.from(positions.keys()));
      for (const anchorId of anchors) {
        const anchorPos = positions.get(Number(anchorId));
        if (!anchorPos) continue;
        const neighbors = graphWalkEdges
          .filter((edge) => Number(edge.fromEntityId) === Number(anchorId) || Number(edge.toEntityId) === Number(anchorId))
          .map((edge) => ({
            edge,
            otherId: Number(edge.fromEntityId) === Number(anchorId) ? Number(edge.toEntityId) : Number(edge.fromEntityId),
          }))
          .filter((row) => nodeIdsToRender.has(row.otherId))
          .sort((a, b) => Number(b.edge.evidenceCount || 0) - Number(a.edge.evidenceCount || 0));
        const unplaced = neighbors.filter((n) => !placed.has(n.otherId));
        const nCount = unplaced.length;
        const radius = 145;
        for (let i = 0; i < nCount; i++) {
          const angle = (-Math.PI / 2) + ((2 * Math.PI) * i / Math.max(1, nCount));
          const x = Math.round(anchorPos.x + Math.cos(angle) * radius);
          const y = Math.round(anchorPos.y + Math.sin(angle) * Math.min(170, radius));
          positions.set(unplaced[i].otherId, {
            x: Math.max(60, Math.min(w - 60, x)),
            y: Math.max(60, Math.min(h - 60, y)),
          });
          placed.add(unplaced[i].otherId);
        }
      }
      for (const id of Array.from(nodeIdsToRender)) {
        if (positions.has(id)) continue;
        positions.set(id, { x: Math.round(w / 2), y: Math.round(h * 0.2) });
      }

      for (const id of Array.from(nodeIdsToRender)) {
        const node = graphWalkNodeMap.get(Number(id));
        if (!node) continue;
        if (Number.isFinite(Number(node.gx)) && Number.isFinite(Number(node.gy))) {
          positions.set(Number(id), {
            x: Math.max(60, Math.min(w - 60, Number(node.gx))),
            y: Math.max(60, Math.min(h - 60, Number(node.gy))),
          });
        } else {
          const p = positions.get(Number(id));
          if (p) {
            node.gx = p.x;
            node.gy = p.y;
          }
        }
      }

      const renderNodes = Array.from(nodeIdsToRender).map((id) => {
        const node = graphWalkNodeMap.get(Number(id));
        const pos = positions.get(Number(id));
        if (!node || !pos) return null;
        return {
          id: Number(id),
          x: pos.x,
          y: pos.y,
          label: node.label,
          entityType: node.entityType,
          nodeRef: node,
        };
      }).filter(Boolean);

      const edgesSvg = graphWalkEdges
        .filter((e) => nodeIdsToRender.has(Number(e.fromEntityId)) && nodeIdsToRender.has(Number(e.toEntityId)))
        .map((edge) => {
          const p1 = positions.get(Number(edge.fromEntityId));
          const p2 = positions.get(Number(edge.toEntityId));
          if (!p1 || !p2) return "";
          const key = graphWalkEdgeKey(edge.fromEntityId, edge.toEntityId, edge.relationType);
          const selected = key === selectedEdgeKey;
          const midX = Math.round((p1.x + p2.x) / 2);
          const midY = Math.round((p1.y + p2.y) / 2);
          const strokeWidth = graphWalkEdgeStrokeWidth({ ...edge, key }, selectedEdgeKey);
          return `
            <g>
              <line class="graph-edge${selected ? " selected" : ""}" x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" style="stroke-width:${strokeWidth}px" />
              <text class="graph-edge-label" x="${midX}" y="${midY - 4}" text-anchor="middle">${escapeHtml(`${edge.relationType} (${Number(edge.evidenceCount || 0)})`)}</text>
            </g>
          `;
        }).join("");

      const nodesSvg = Array.from(nodeIdsToRender).map((id) => {
        const node = graphWalkNodeMap.get(Number(id));
        const pos = positions.get(Number(id));
        if (!node || !pos) return "";
        const isFocus = Number(id) === focusId;
        const inTrail = trailIds.includes(Number(id));
        const isSelectedConnNode = Boolean(selectedConnectionContext && Number(selectedConnectionContext.toEntityId || 0) === Number(id));
        const r = graphWalkNodeRadius(id, focusId);
        const label = graphWalkShortLabel(node.label, isFocus ? 28 : 20);
        const sub = graphWalkKindLabel(node.entityType);
        return `
          <g class="graph-node${isFocus ? " focus" : ""}${inTrail ? " trail" : ""}${isSelectedConnNode ? " selected-connection" : ""}" data-graph-node-id="${Number(id)}" transform="translate(${pos.x},${pos.y})">
            <circle cx="0" cy="0" r="${r}"></circle>
            <text x="0" y="-2" text-anchor="middle">${escapeHtml(label)}</text>
            <text class="graph-node-sub" x="0" y="${r + 14}" text-anchor="middle">${escapeHtml(sub)}</text>
          </g>
        `;
        }).join("");

      const renderEdges = graphWalkEdges
        .filter((e) => nodeIdsToRender.has(Number(e.fromEntityId)) && nodeIdsToRender.has(Number(e.toEntityId)))
        .map((e) => ({
          fromEntityId: Number(e.fromEntityId),
          toEntityId: Number(e.toEntityId),
          relationType: String(e.relationType || ""),
          evidenceCount: Number(e.evidenceCount || 0),
          edgeCount: Number(e.edgeCount || 0),
        }));

      if (graphWalkSvgEl instanceof SVGElement) {
        const renderedByD3 = renderGraphWalkWithD3(renderNodes, renderEdges, { focusId, selectedEdgeKey });
        if (!renderedByD3) {
          graphWalkSvgEl.innerHTML = `${edgesSvg}${nodesSvg}`;
        }
      }

      if (graphWalkBreadcrumbsEl instanceof HTMLElement) {
        const crumbs = [];
        for (let i = 0; i < trailIds.length; i++) {
          const id = Number(trailIds[i]);
          const node = graphWalkNodeMap.get(id);
          if (!node) continue;
          if (i > 0) crumbs.push(`<span class="graph-walk-crumb-arrow">â†’</span>`);
          crumbs.push(`<button type="button" class="graph-walk-crumb${id === focusId ? " active" : ""}" data-graph-crumb-id="${id}">${escapeHtml(graphWalkShortLabel(node.label, 36))}</button>`);
        }
        graphWalkBreadcrumbsEl.innerHTML = crumbs.join("");
      }

      const focusNode = graphWalkNodeMap.get(focusId) || graphWalkFocusEntity;
      if (graphWalkNodeDetailsEl instanceof HTMLElement) {
        const meta = graphWalkNodeSummary(focusNode);
        const bindings = Array.isArray(focusNode?.bindings) ? focusNode.bindings : [];
        graphWalkNodeDetailsEl.innerHTML = `
          <div class="entity-title">${escapeHtml(graphWalkKindLabel(focusNode?.entityType || ""))}</div>
          <div class="entity-title" style="margin:0;color:#23312d;font-weight:700;font-size:.92rem;">${escapeHtml(focusNode?.label || "Focus")}</div>
          ${meta ? `<div class="meta">${escapeHtml(meta)}</div>` : `<div class="meta">No additional metadata loaded.</div>`}
          ${bindings.length ? `<div class="entity-list">${bindings.slice(0, 4).map((b) => `<span class="entity-chip">${escapeHtml(`${b.source_table}:${b.source_id}`)}</span>`).join("")}</div>` : ""}
          <div class="meta">neighbors loaded: ${graphWalkNeighborRowsForFocus().length}${graphWalkLoading ? " â€¢ loadingâ€¦" : ""}</div>
        `;
      }

      const focusNeighborRows = graphWalkNeighborRowsForFocus();
      if (graphWalkNeighborListEl instanceof HTMLElement) {
        if (!focusNeighborRows.length) {
          graphWalkNeighborListEl.innerHTML = `<div class="graph-walk-empty">${graphWalkLoading ? "Loading graph neighborhood..." : "No neighbors loaded for the current focus."}</div>`;
        } else {
          graphWalkNeighborListEl.innerHTML = focusNeighborRows.map((row) => {
            const active = Boolean(
              selectedConnectionContext &&
              Number(selectedConnectionContext.toEntityId || 0) === Number(row.entityId) &&
              String(selectedConnectionContext.relationType || "") === String(row.relationType || "") &&
              String(selectedConnectionContext.direction || "") === String(row.direction || "")
            );
            const node = graphWalkNodeMap.get(Number(row.entityId)) || row;
            const meta = graphWalkNodeSummary(node);
            return `
              <div class="graph-walk-row${active ? " active" : ""}">
                <div class="graph-walk-row-head">
                  <button type="button" class="graph-walk-row-title" data-graph-walk-node-id="${row.entityId}">${escapeHtml(row.label)}</button>
                  <span class="entity-chip">${escapeHtml(graphWalkKindLabel(row.entityType))}</span>
                </div>
                <div class="graph-walk-row-meta">${escapeHtml(`${row.direction} â€¢ ${row.relationType} â€¢ evidence ${row.evidenceCount} â€¢ meetings ${row.sharedMeetingCount}`)}</div>
                ${meta ? `<div class="graph-walk-row-meta">${escapeHtml(meta)}</div>` : ""}
                <div class="graph-walk-row-actions">
                  <button type="button" data-graph-walk-node-id="${row.entityId}">Walk</button>
                  <button type="button"
                    data-connection-evidence-entity-id="${row.entityId}"
                    data-connection-relation-type="${escapeHtml(row.relationType)}"
                    data-connection-direction="${escapeHtml(row.direction)}">View Evidence</button>
                  <button type="button"
                    data-entity-mentions-id="${row.entityId}"
                    data-entity-mentions-preserve-focus="1"
                    data-entity-mentions-label="${escapeHtml(row.label)}">View Mentions</button>
                </div>
              </div>
            `;
          }).join("");
        }
      }

      if (graphWalkTrailSummaryEl instanceof HTMLElement) {
        const labels = trailIds
          .map((id) => graphWalkNodeMap.get(Number(id))?.label || `Entity ${id}`)
          .map((label) => graphWalkShortLabel(label, 34));
        graphWalkTrailSummaryEl.textContent = labels.length
          ? `Trail: ${labels.join(" â†’ ")}`
          : "Walk the graph by clicking a neighbor node.";
      }
    }

    async function syncGraphWalkFromCurrentFocus({ forceReset = false } = {}) {
      if (activeMainView !== "graph") return;
      const preserveTrailOnFocusChange = Boolean(graphWalkPreserveTrailOnNextFocusSync);
      graphWalkPreserveTrailOnNextFocusSync = false;
      const sourceNode = currentGraphFocusSourceNode();
      if (!sourceNode) {
        if (selectedMeetingContext?.meetingId && !lastConnectionFocus?.entityId) {
          if (graphWalkEmptyEl instanceof HTMLElement) {
            graphWalkEmptyEl.hidden = false;
            graphWalkEmptyEl.textContent = `Resolving graph node for Meeting ${selectedMeetingContext.meetingId}...`;
          }
          void loadMeetingFocusConnections(selectedMeetingContext.meetingId);
          renderGraphWalk();
          return;
        }
        clearGraphWalkState();
        return;
      }
      const sameFocus = Number(graphWalkFocusEntity?.entityId || 0) === Number(sourceNode.entityId || 0);
      if (!forceReset && sameFocus && graphWalkExpandedNodeIds.has(Number(sourceNode.entityId || 0))) {
        graphWalkFocusEntity = graphWalkStoreNode(sourceNode) || graphWalkFocusEntity;
        renderGraphWalk();
        return;
      }
      const shouldResetGraph = forceReset || (!sameFocus && !preserveTrailOnFocusChange);
      const shouldResetTrail = forceReset || (!sameFocus && !preserveTrailOnFocusChange);
      if (shouldResetGraph) {
        graphWalkNodeMap = new Map();
        graphWalkEdges = [];
        graphWalkExpandedNodeIds = new Set();
      }
      await graphWalkExpandNodeNeighborhood(sourceNode, { resetTrail: shouldResetTrail });
    }

    async function graphWalkFocusNodeById(entityId) {
      const id = Number(entityId || 0);
      if (!Number.isFinite(id) || id <= 0) return;
      const node = graphWalkNodeMap.get(id);
      if (!node) return;
      const label = String(node.label || `Entity ${id}`);
      const entityType = String(node.entityType || "").trim().toLowerCase();
      setSidebarView("search");
      const meetingBinding = Array.isArray(node.bindings)
        ? node.bindings.find((b) => String(b.source_table || "") === "meetings" && Number(b.source_id || 0) > 0)
        : null;

      if (entityType === "meeting" && meetingBinding) {
        graphWalkPreserveTrailOnNextFocusSync = true;
        await openStoredMeeting(Number(meetingBinding.source_id), {
          name: String(node.kindMetadata?.name || ""),
          location: String(node.kindMetadata?.location || ""),
          time: String(node.kindMetadata?.time || ""),
        }, { focusMeeting: true });
        return;
      }

      entitySearchEl.value = label;
      setGlobalEntityFilter(label);
      setSelectedEntityContext({
        entityId: id,
        label,
        entityType,
        bindings: node.bindings || [],
        kindMetadata: node.kindMetadata || {},
      });
      graphWalkPreserveTrailOnNextFocusSync = true;
      await loadEntityConnections(id, label, entityType, node.bindings || [], node.kindMetadata || {});
    }

    function mountOperationsPanelInSidebar() {
      if (!(operationsPanelEl instanceof HTMLElement) || !(operationsMountEl instanceof HTMLElement)) return;
      if (!operationsMountEl.contains(operationsPanelEl)) {
        operationsMountEl.appendChild(operationsPanelEl);
      }
      if (operationsHeadEl instanceof HTMLElement) operationsHeadEl.hidden = true;
      if (operationsPlaceholderEl instanceof HTMLElement) operationsPlaceholderEl.hidden = false;
      syncWorkspaceHeight();
    }

    function mountExplorerControlsTop() {
      if (!(topFilterControlsMountEl instanceof HTMLElement) || !(entityExplorerControlsBlockEl instanceof HTMLElement)) return;
      if (!topFilterControlsMountEl.contains(entityExplorerControlsBlockEl)) {
        topFilterControlsMountEl.appendChild(entityExplorerControlsBlockEl);
      }
      if (filterBarPanelEl instanceof HTMLElement) {
        const headerEl = entityExplorerControlsBlockEl.querySelector(".entity-panel-header");
        const facetGridEl = headerEl instanceof HTMLElement ? headerEl.querySelector(".facet-control-grid") : null;
        if (headerEl instanceof HTMLElement) {
          const currentParent = filterBarPanelEl.parentElement;
          if (currentParent !== headerEl) {
            headerEl.insertBefore(filterBarPanelEl, facetGridEl instanceof HTMLElement ? facetGridEl : null);
          }
          if (topFilterMountEl instanceof HTMLElement) topFilterMountEl.hidden = true;
        }
      }
      const searchPanel = document.querySelector(".search-panel");
      if (searchPanel instanceof HTMLElement) searchPanel.classList.add("controls-moved");
      syncWorkspaceHeight();
    }

    function mountFilterBarIntoTopPanel() {
      if (!(topFilterMountEl instanceof HTMLElement) || !(filterBarPanelEl instanceof HTMLElement)) return;
      if (!topFilterMountEl.contains(filterBarPanelEl)) {
        topFilterMountEl.appendChild(filterBarPanelEl);
      }
      syncWorkspaceHeight();
    }

    function mountEntitySearchIntoTopPanel() {
      if (!(topSearchMountEl instanceof HTMLElement) || !(entitySearchControlBlockEl instanceof HTMLElement)) return;
      if (!topSearchMountEl.contains(entitySearchControlBlockEl)) {
        topSearchMountEl.appendChild(entitySearchControlBlockEl);
      }
      syncWorkspaceHeight();
    }

    function mountExplorationSectionsInLeftPane() {
      if (!(leftExplorationMountEl instanceof HTMLElement)) return;
      const pivotSections = [entityMatchesSectionEl, meetingMatchesSectionEl];
      for (const section of pivotSections) {
        if (!(section instanceof HTMLElement)) continue;
        section.classList.remove("collapsed");
        section.classList.add("evidence-flat");
        if (leftPivotMountEl instanceof HTMLElement && !leftPivotMountEl.contains(section)) {
          leftPivotMountEl.appendChild(section);
        }
      }
      const evidenceSections = [contentMatchesSectionEl, mentionsSectionEl];
      for (const section of evidenceSections) {
        if (!(section instanceof HTMLElement)) continue;
        section.classList.remove("collapsed");
        section.classList.add("evidence-flat");
        if (section === mentionsSectionEl) {
          if (leftEdgeEvidenceMountEl instanceof HTMLElement && !leftEdgeEvidenceMountEl.contains(section)) {
            leftEdgeEvidenceMountEl.appendChild(section);
          }
          continue;
        }
        if (!leftExplorationMountEl.contains(section)) {
          leftExplorationMountEl.appendChild(section);
        }
      }
      if (leftRelatedMountEl instanceof HTMLElement && relatedEntitiesSectionEl instanceof HTMLElement) {
        if (!leftRelatedMountEl.contains(relatedEntitiesSectionEl)) {
          leftRelatedMountEl.appendChild(relatedEntitiesSectionEl);
        }
      }
      if (leftConnectionsTopicsMountEl instanceof HTMLElement && relatedEl instanceof HTMLElement) {
        if (!leftConnectionsTopicsMountEl.contains(relatedEl)) {
          leftConnectionsTopicsMountEl.appendChild(relatedEl);
        }
      }
      if (leftConnectionsMeetingsMountEl instanceof HTMLElement && meetingListPanelEl instanceof HTMLElement) {
        if (!leftConnectionsMeetingsMountEl.contains(meetingListPanelEl)) {
          leftConnectionsMeetingsMountEl.appendChild(meetingListPanelEl);
        }
      }
      if (leftConnectionsMatchesMountEl instanceof HTMLElement) {
        leftConnectionsMatchesMountEl.innerHTML = "";
      }
      if (leftEvidenceMeetingMountEl instanceof HTMLElement) {
        if (resultsHeadEl instanceof HTMLElement) {
          resultsHeadEl.hidden = true;
        }
        if (meetingDetailPanelEl instanceof HTMLElement && !leftEvidenceMeetingMountEl.contains(meetingDetailPanelEl)) {
          leftEvidenceMeetingMountEl.appendChild(meetingDetailPanelEl);
        }
      }
      if (meetingMasterDetailEl instanceof HTMLElement) {
        meetingMasterDetailEl.hidden = true;
      }
      syncWorkspaceHeight();
    }

    function mountExistingDataPanelInLeftPane() {
      if (!(leftExistingDataMountEl instanceof HTMLElement) || !(existingDataPanelEl instanceof HTMLElement)) return;
      for (const section of [popularTopicsSectionEl, popularEntitiesSectionEl]) {
        if (section instanceof HTMLElement && !leftExistingDataMountEl.contains(section)) {
          leftExistingDataMountEl.appendChild(section);
        }
      }
      if (!leftExistingDataMountEl.contains(existingDataPanelEl)) {
        leftExistingDataMountEl.appendChild(existingDataPanelEl);
      }
      syncWorkspaceHeight();
    }

    function positionExplorationFlowPanels() {
      if (!(mainColEl instanceof HTMLElement)) return;
      const hasFocus = Boolean(
        (selectedEntityContext && selectedEntityContext.label) ||
        (selectedMeetingContext && selectedMeetingContext.meetingId)
      );
      if (existingDataWorkspacePanelEl instanceof HTMLElement) {
        const preFocusAnchor = entityContextPanelEl instanceof HTMLElement ? entityContextPanelEl : explorationWorkspacePanelEl;
        const focusedAnchor = relatedEntitiesWorkspacePanelEl instanceof HTMLElement ? relatedEntitiesWorkspacePanelEl.nextElementSibling : null;
        if (!hasFocus && preFocusAnchor instanceof HTMLElement) {
          if (existingDataWorkspacePanelEl !== preFocusAnchor.previousElementSibling) {
            mainColEl.insertBefore(existingDataWorkspacePanelEl, preFocusAnchor);
          }
        } else if (hasFocus && relatedEntitiesWorkspacePanelEl instanceof HTMLElement) {
          if (focusedAnchor !== existingDataWorkspacePanelEl) {
            mainColEl.insertBefore(existingDataWorkspacePanelEl, focusedAnchor);
          }
        }
      }
      if (relatedEntitiesWorkspacePanelEl instanceof HTMLElement && explorationWorkspacePanelEl instanceof HTMLElement) {
        if (relatedEntitiesWorkspacePanelEl.nextElementSibling !== explorationWorkspacePanelEl) {
          mainColEl.insertBefore(relatedEntitiesWorkspacePanelEl, explorationWorkspacePanelEl);
        }
      }
      if (
        explorationWorkspacePanelEl instanceof HTMLElement &&
        relatedEntitiesWorkspacePanelEl instanceof HTMLElement &&
        pivotResultsWorkspacePanelEl instanceof HTMLElement
      ) {
        if (explorationWorkspacePanelEl.nextElementSibling !== pivotResultsWorkspacePanelEl) {
          mainColEl.insertBefore(pivotResultsWorkspacePanelEl, explorationWorkspacePanelEl.nextElementSibling);
        }
      }
      syncWorkspaceHeight();
    }

    function updateDiscoveryStartsVisibility() {
      if (!(existingDataWorkspacePanelEl instanceof HTMLElement)) return;
      const hasFocus = Boolean(
        (selectedEntityContext && selectedEntityContext.label) ||
        (selectedMeetingContext && selectedMeetingContext.meetingId)
      );
      existingDataWorkspacePanelEl.hidden = hasFocus;
      positionExplorationFlowPanels();
      syncWorkspaceHeight();
    }

    function updateExplorationWorkspaceVisibility() {
      if (!(leftExplorationEmptyEl instanceof HTMLElement)) return;
      const hasAny =
        (contentSearchResultsEl.innerHTML || "").trim() ||
        (entityMentionsResultsEl.innerHTML || "").trim() ||
        Boolean(selectedContextMeetingId) ||
        Boolean((selectedMeetingContext && selectedMeetingContext.meetingId));
      leftExplorationEmptyEl.hidden = Boolean(hasAny);
      if (explorationWorkspacePanelEl instanceof HTMLElement) {
        explorationWorkspacePanelEl.hidden = false;
      }
      updateEvidencePanelMode();
      syncWorkspaceHeight();
    }

    function setFacetSectionState(sectionEl, { active = false, expand = false, scrollIntoView = false } = {}) {
      if (!(sectionEl instanceof HTMLElement)) return;
      sectionEl.hidden = false;
      sectionEl.classList.toggle("facet-active", Boolean(active));
      if (expand) sectionEl.classList.remove("collapsed");
      if (scrollIntoView) {
        const scroller = sectionEl.closest(".sidebar-scroll");
        if (scroller instanceof HTMLElement) {
          const top = Math.max(0, sectionEl.offsetTop - 8);
          scroller.scrollTo({ top, behavior: "smooth" });
        }
      }
      syncWorkspaceHeight();
    }

    function setSidebarView(view) {
      activeSidebarView = view;
      const allTabs = [
        [tabSearchEl, "search"],
        [tabTimelineEl, "timeline"],
        [tabMapEl, "map"],
      ];
      for (const [el, key] of allTabs) el.classList.toggle("active", key === view);

      const searchVisible = true;
      entitySearchResultsEl.hidden = !searchVisible;
      meetingSearchResultsEl.hidden = !searchVisible;
      contentSearchResultsEl.hidden = !searchVisible;
      entityRelatedResultsEl.hidden = !searchVisible;
      entityMentionsResultsEl.hidden = !searchVisible;
      if (startupTopicsResultsEl instanceof HTMLElement) startupTopicsResultsEl.hidden = !searchVisible;
      if (startupEntitiesResultsEl instanceof HTMLElement) startupEntitiesResultsEl.hidden = !searchVisible;
      if (leftExplorationMountEl instanceof HTMLElement && leftExplorationMountEl.contains(entitySearchResultsEl)) {
        entitySearchResultsEl.hidden = false;
        meetingSearchResultsEl.hidden = false;
        contentSearchResultsEl.hidden = false;
        entityMentionsResultsEl.hidden = false;
      }
      if (leftRelatedMountEl instanceof HTMLElement && leftRelatedMountEl.contains(entityRelatedResultsEl)) {
        entityRelatedResultsEl.hidden = false;
      }
      const popularMovedLeft = leftExistingDataMountEl instanceof HTMLElement && (
        (popularTopicsSectionEl instanceof HTMLElement && leftExistingDataMountEl.contains(popularTopicsSectionEl)) ||
        (popularEntitiesSectionEl instanceof HTMLElement && leftExistingDataMountEl.contains(popularEntitiesSectionEl))
      );
      if (popularMovedLeft) {
        if (startupTopicsResultsEl instanceof HTMLElement) startupTopicsResultsEl.hidden = false;
        if (startupEntitiesResultsEl instanceof HTMLElement) startupEntitiesResultsEl.hidden = false;
      }
      setFacetSectionState(timelineSectionEl, { active: view === "timeline" });
      setFacetSectionState(mapSectionEl, { active: view === "map" });
    }

    function setIngestStatus(msg, isError = false) {
      ingestStatusEl.textContent = msg;
      ingestStatusEl.style.color = isError ? "#b91c1c" : "#5e645f";
      syncWorkspaceHeight();
    }

    function setBrowseStatus(msg, isError = false) {
      browseStatusEl.textContent = msg;
      browseStatusEl.style.color = isError ? "#b91c1c" : "#5e645f";
      syncWorkspaceHeight();
    }

    function renderGlobalFilterChips() {
      const chips = [];
      if (globalFilters.topic) {
        chips.push(`<span class="filter-chip topic">Topic: ${globalFilters.topic}<button type="button" data-remove-filter="topic">x</button></span>`);
      }
      if (globalFilters.entityType) {
        chips.push(`<span class="filter-chip entity">Kind: ${globalFilters.entityType}<button type="button" data-remove-filter="entityType">x</button></span>`);
      }
      activeFilterChipsEl.innerHTML = chips.join("") || `<span class="filter-empty">No global filters selected. Focused entities and meetings are pinned in Current Focus / Focus Snapshot.</span>`;
      clearAllFiltersBtn.hidden = chips.length === 0;
      syncWorkspaceHeight();
    }

    function updateEntityTypeFilterButtons() {
      if (!(entityTypeFilterRowEl instanceof HTMLElement)) return;
      const selected = (globalFilters.entityType || "").trim().toLowerCase();
      for (const btn of entityTypeFilterRowEl.querySelectorAll("[data-entity-type-filter]")) {
        if (!(btn instanceof HTMLElement)) continue;
        const value = String(btn.dataset.entityTypeFilter || "").trim().toLowerCase();
        btn.classList.toggle("active", value === selected);
      }
    }

    function setGlobalTopicFilter(topic) {
      globalFilters.topic = (topic || "").trim();
      topicEl.value = globalFilters.topic;
      renderGlobalFilterChips();
    }

    function setGlobalEntityFilter(query) {
      globalFilters.entityQuery = (query || "").trim();
      entitySearchEl.value = globalFilters.entityQuery;
      renderGlobalFilterChips();
    }

    function setGlobalEntityTypeFilter(entityType) {
      globalFilters.entityType = String(entityType || "").trim().toLowerCase();
      updateEntityTypeFilterButtons();
      renderGlobalFilterChips();
      updateResultsContextHeader();
      renderGraphWalk();
    }

    function setGlobalMeetingFilter(meetingId) {
      globalFilters.meetingId = meetingId ? Number(meetingId) : null;
      selectedStoredMeetingId = globalFilters.meetingId;
      renderGlobalFilterChips();
      updateResultsContextHeader();
    }

    function updateResultsContextHeader() {
      if (!(resultsContextSummaryEl instanceof HTMLElement)) return;
      const bits = [];
      if (globalFilters.meetingId) bits.push(`meeting ${globalFilters.meetingId}`);
      if (globalFilters.entityQuery) bits.push(`entity "${globalFilters.entityQuery}"`);
      if (globalFilters.entityType) bits.push(`kind ${globalFilters.entityType}`);
      if (globalFilters.topic) bits.push(`topic "${globalFilters.topic}"`);
      resultsContextSummaryEl.textContent = bits.length
        ? `Evidence for ${bits.join(" â€¢ ")}. Agenda items, documents, mentions, and meeting details stay synchronized with the shared filter bar.`
        : "Evidence panels stay synchronized with the active global filters and current focus.";
    }

    function updateEvidencePanelMode() {
      const hasSelectedConnection = Boolean(
        selectedConnectionContext &&
        selectedConnectionContext.fromLabel &&
        selectedConnectionContext.toLabel
      );
      if (evidencePanelTitleEl instanceof HTMLElement) {
        evidencePanelTitleEl.textContent = hasSelectedConnection ? "Evidence (Selected Connection)" : "Evidence";
      }
      if (evidencePanelSubEl instanceof HTMLElement) {
        evidencePanelSubEl.textContent = hasSelectedConnection
          ? "Proof rows and source snippets for the selected edge. Node-level search matches are moved to Pivot Results."
          : "Review source snippets and supporting material for the current node or selected connection.";
      }
      if (contentMatchesSectionEl instanceof HTMLElement) {
        contentMatchesSectionEl.hidden = hasSelectedConnection;
      }
      if (meetingDetailPanelEl instanceof HTMLElement) {
        meetingDetailPanelEl.hidden = hasSelectedConnection;
      }
      if (mentionsSectionTitleEl instanceof HTMLElement) {
        mentionsSectionTitleEl.textContent = hasSelectedConnection ? "Selected Edge Evidence" : "Mentions";
      }
      if (leftEdgeEvidenceTitleEl instanceof HTMLElement) {
        leftEdgeEvidenceTitleEl.textContent = hasSelectedConnection ? "Selected Edge Proof" : "Node Mentions";
      }
      if (contentMatchesSectionTitleEl instanceof HTMLElement) {
        contentMatchesSectionTitleEl.textContent = hasSelectedConnection
          ? "Hidden (Connection Mode)"
          : "Evidence Search Matches (Agenda & Documents)";
      }
      if (leftNodeEvidencePanelEl instanceof HTMLElement) {
        leftNodeEvidencePanelEl.hidden = hasSelectedConnection;
      }
      if (leftEdgeEvidencePanelEl instanceof HTMLElement) {
        const edgeHasContent = Boolean((entityMentionsResultsEl.innerHTML || "").trim());
        leftEdgeEvidencePanelEl.hidden = !edgeHasContent && !hasSelectedConnection;
      }
      if (pivotResultsWorkspacePanelEl instanceof HTMLElement) {
        const hasPivotContent = Boolean(
          (entitySearchResultsEl.innerHTML || "").trim() || (meetingSearchResultsEl.innerHTML || "").trim()
        );
        pivotResultsWorkspacePanelEl.hidden = !hasPivotContent;
      }
      syncWorkspaceHeight();
    }

    let evidenceFlashTimer = null;
    function focusEvidencePanel(targetEl = null) {
      const panel = explorationWorkspacePanelEl instanceof HTMLElement ? explorationWorkspacePanelEl : null;
      if (panel && mainColEl instanceof HTMLElement) {
        const offset = Math.max(0, panel.offsetTop - 8);
        mainColEl.scrollTo({ top: offset, behavior: "smooth" });
      }
      const flashTarget = (targetEl instanceof HTMLElement ? targetEl : panel);
      if (!(flashTarget instanceof HTMLElement)) return;
      flashTarget.classList.remove("flash-focus");
      // Force reflow so repeated clicks retrigger animation.
      void flashTarget.offsetWidth;
      flashTarget.classList.add("flash-focus");
      if (evidenceFlashTimer) clearTimeout(evidenceFlashTimer);
      evidenceFlashTimer = setTimeout(() => {
        flashTarget.classList.remove("flash-focus");
      }, 1300);
    }

    function updateConnectionsMeetingsTitle() {
      if (!(connectionsMeetingsTitleEl instanceof HTMLElement)) return;
      const meetingFocused = Boolean(selectedMeetingContext && selectedMeetingContext.meetingId);
      const entityFocused = Boolean(selectedEntityContext && selectedEntityContext.label);
      connectionsMeetingsTitleEl.textContent = (meetingFocused && !entityFocused)
        ? "Other Meetings in Current Filter Context"
        : "Contextual Meetings";
    }

    function focusKeyForEntity(entity) {
      if (!entity || !entity.entityId) return "";
      return `entity:${Number(entity.entityId)}`;
    }

    function focusKeyForMeeting(meeting) {
      if (!meeting || !meeting.meetingId) return "";
      return `meeting:${Number(meeting.meetingId)}`;
    }

    function clearSelectedConnection({ preserveEvidencePanel = false } = {}) {
      selectedConnectionContext = null;
      if (topSelectedConnectionPanelEl instanceof HTMLElement) topSelectedConnectionPanelEl.hidden = true;
      if (topSelectedConnectionSubEl instanceof HTMLElement) topSelectedConnectionSubEl.textContent = "No connection selected.";
      if (topSelectedConnectionStatsEl instanceof HTMLElement) topSelectedConnectionStatsEl.innerHTML = "";
      if (!preserveEvidencePanel && entityMentionsResultsEl instanceof HTMLElement && !lastEntityMentionsEntity) {
        entityMentionsResultsEl.innerHTML = "";
      }
      renderLeftEntityContext();
      renderGraphWalk();
    }

    function renderTopSelectedConnectionCard() {
      if (!(topSelectedConnectionPanelEl instanceof HTMLElement)) return;
      if (!selectedConnectionContext || !selectedConnectionContext.fromLabel || !selectedConnectionContext.toLabel) {
        topSelectedConnectionPanelEl.hidden = true;
        return;
      }
      topSelectedConnectionPanelEl.hidden = false;
      const arrow = selectedConnectionContext.direction === "outgoing" ? "â†’" : "â†";
      if (topSelectedConnectionSubEl instanceof HTMLElement) {
        topSelectedConnectionSubEl.textContent = `${selectedConnectionContext.fromLabel} ${arrow} ${selectedConnectionContext.toLabel} (${selectedConnectionContext.relationType})`;
      }
      const stats = [];
      if (Number.isFinite(Number(selectedConnectionContext.evidenceCount))) {
        stats.push(`evidence: ${Number(selectedConnectionContext.evidenceCount)}`);
      }
      if (Number.isFinite(Number(selectedConnectionContext.sharedMeetingCount))) {
        stats.push(`shared meetings: ${Number(selectedConnectionContext.sharedMeetingCount)}`);
      }
      if (Number.isFinite(Number(selectedConnectionContext.edgeCount))) {
        stats.push(`edges: ${Number(selectedConnectionContext.edgeCount)}`);
      }
      const rowCount = Array.isArray(selectedConnectionContext.rows) ? selectedConnectionContext.rows.length : 0;
      if (rowCount) stats.push(`loaded rows: ${rowCount}`);
      topSelectedConnectionStatsEl.innerHTML = stats.map((s) => `<span class="focus-stat">${s}</span>`).join("");
    }

    function setMeetingDetailCollapsed(collapsed) {
      meetingDetailCollapsed = Boolean(collapsed);
      if (meetingDetailPanelEl instanceof HTMLElement) {
        meetingDetailPanelEl.classList.toggle("collapsed", meetingDetailCollapsed);
      }
      if (meetingDetailToggleEl instanceof HTMLElement) {
        meetingDetailToggleEl.textContent = meetingDetailCollapsed ? "Expand" : "Collapse";
        meetingDetailToggleEl.setAttribute("aria-expanded", String(!meetingDetailCollapsed));
      }
      syncWorkspaceHeight();
    }

    function clearSelectedMeetingDetailView() {
      selectedContextMeetingId = null;
      if (Array.isArray(lastMeetingResults) && lastMeetingResults.length) {
        renderSelectedMeetingDetail(lastMeetingResults, topicEl.value || "");
        renderContextualMeetingList(lastMeetingResults, topicEl.value || "");
      } else if (meetingDetailTitleEl instanceof HTMLElement && meetingDetailSubEl instanceof HTMLElement) {
        meetingDetailTitleEl.textContent = "Selected Meeting Detail";
        meetingDetailSubEl.textContent = "Choose a meeting from the contextual list.";
        resultsEl.innerHTML = `<article class="meeting"><div class="meta">No meeting selected.</div></article>`;
      }
      syncWorkspaceHeight();
    }

    function setPinnedFocusSnapshotCollapsed(collapsed) {
      pinnedFocusSnapshotCollapsed = Boolean(collapsed);
      if (pinnedFocusSnapshotPanelEl instanceof HTMLElement) {
        pinnedFocusSnapshotPanelEl.classList.toggle("collapsed", pinnedFocusSnapshotCollapsed);
      }
      if (pinnedFocusSnapshotToggleEl instanceof HTMLElement) {
        pinnedFocusSnapshotToggleEl.textContent = pinnedFocusSnapshotCollapsed ? "Expand" : "Collapse";
        pinnedFocusSnapshotToggleEl.setAttribute("aria-expanded", String(!pinnedFocusSnapshotCollapsed));
      }
      syncWorkspaceHeight();
    }

    function setFocusSnapshotMeetingPreviewCollapsed(collapsed) {
      focusSnapshotMeetingPreviewCollapsed = Boolean(collapsed);
      renderPinnedFocusSnapshot();
    }

    function setTopExplorerCompact(collapsed) {
      topExplorerCompact = Boolean(collapsed);
      if (topExplorerControlsPanelEl instanceof HTMLElement) {
        topExplorerControlsPanelEl.classList.toggle("compact", topExplorerCompact);
      }
      if (document.body instanceof HTMLElement) {
        document.body.classList.toggle("top-compact", topExplorerCompact);
      }
      if (topExplorerCompactToggleEl instanceof HTMLElement) {
        topExplorerCompactToggleEl.textContent = topExplorerCompact ? "Expand" : "Compact";
        topExplorerCompactToggleEl.setAttribute("aria-expanded", String(!topExplorerCompact));
      }
      syncWorkspaceHeight();
    }

    function renderPinnedFocusSnapshot() {
      if (!(pinnedFocusSnapshotPanelEl instanceof HTMLElement) || !(pinnedFocusSnapshotBodyEl instanceof HTMLElement)) return;
      const hasMeeting = Boolean(selectedMeetingContext && selectedMeetingContext.meetingId);
      const hasEntity = Boolean(selectedEntityContext && selectedEntityContext.label);
      const hasConnection = Boolean(selectedConnectionContext && selectedConnectionContext.fromLabel && selectedConnectionContext.toLabel);

      if (!hasMeeting && !hasEntity && !hasConnection) {
        pinnedFocusSnapshotPanelEl.hidden = true;
        pinnedFocusSnapshotBodyEl.innerHTML = "";
        return;
      }

      pinnedFocusSnapshotPanelEl.hidden = false;
      if (pinnedFocusSnapshotSubEl instanceof HTMLElement) {
        pinnedFocusSnapshotSubEl.textContent = hasConnection
          ? "Pinned focus and selected connection while you inspect connections and evidence below."
          : "Pinned focus details while you inspect connections and evidence below.";
      }

      const blocks = [];
      const focusedMeetingResult = (hasMeeting && selectedMeetingContext)
        ? (Array.isArray(lastMeetingResults)
          ? lastMeetingResults.find((r) => Number(r.meetingId) === Number(selectedMeetingContext.meetingId)) || null
          : null)
        : null;
      if (hasMeeting && selectedMeetingContext) {
        const title = selectedMeetingContext.name
          ? `Meeting ${selectedMeetingContext.meetingId} â€¢ ${selectedMeetingContext.name}`
          : `Meeting ${selectedMeetingContext.meetingId}`;
        const metaBits = [selectedMeetingContext.location, selectedMeetingContext.time].filter(Boolean);
        const stats = [
          `agenda: ${selectedMeetingContext.agendaItemCount}`,
          `docs: ${selectedMeetingContext.documentCount}`,
          `entities: ${selectedMeetingContext.entityCount}`,
          `minutes: ${selectedMeetingContext.minutesCount}`,
        ];
        const previewHtml = (() => {
          if (focusSnapshotMeetingPreviewCollapsed) return "";
          if (!focusedMeetingResult) {
            return `<div class="focus-snapshot-preview"><div class="focus-snapshot-preview-section"><div class="focus-snapshot-preview-title">Meeting Detail Preview</div><div class="row meta">Meeting detail preview will appear after contextual meeting data loads.</div></div></div>`;
          }
          const agendaItems = Array.isArray(focusedMeetingResult.agendaItems) ? focusedMeetingResult.agendaItems : [];
          const minutesRows = Array.isArray(focusedMeetingResult.minutesMetadata) ? focusedMeetingResult.minutesMetadata : [];
          const docs = [];
          const seenDocs = new Set();
          for (const item of agendaItems) {
            for (const d of (item.documents || [])) {
              const key = `${d.document_id}:${d.url}`;
              if (seenDocs.has(key)) continue;
              seenDocs.add(key);
              docs.push(d);
            }
          }
          const topAgenda = agendaItems.slice(0, 4);
          const topDocs = docs.slice(0, 4);
          const topMinutes = minutesRows.slice(0, 3);
          return `
            <div class="focus-snapshot-preview">
              <div class="focus-snapshot-preview-section">
                <div class="focus-snapshot-preview-title">Agenda Preview (${agendaItems.length})</div>
                <div class="focus-snapshot-preview-list">
                  ${topAgenda.length ? topAgenda.map((item) => `<div class="row"><strong>${escapeHtml(item.item_key || "")}</strong> ${escapeHtml(item.title || "")}</div>`).join("") : `<div class="row meta">No agenda items loaded.</div>`}
                  ${agendaItems.length > topAgenda.length ? `<div class="row meta">...and ${agendaItems.length - topAgenda.length} more agenda item(s)</div>` : ""}
                </div>
              </div>
              <div class="focus-snapshot-preview-section">
                <div class="focus-snapshot-preview-title">Documents (${docs.length})</div>
                <div class="focus-snapshot-preview-list">
                  ${topDocs.length ? topDocs.map((d) => `<div class="row"><a href="${d.url}" target="_blank" rel="noreferrer">${escapeHtml(d.title || `document ${d.document_id}`)}</a></div>`).join("") : `<div class="row meta">No documents loaded.</div>`}
                  ${docs.length > topDocs.length ? `<div class="row meta">...and ${docs.length - topDocs.length} more document(s)</div>` : ""}
                </div>
              </div>
              <div class="focus-snapshot-preview-section">
                <div class="focus-snapshot-preview-title">Minutes Metadata (${minutesRows.length})</div>
                <div class="focus-snapshot-preview-list">
                  ${topMinutes.length ? topMinutes.map((m) => `<div class="row">${escapeHtml(m.title || `doc ${m.document_id}`)}${m.status ? ` <span class="meta">(status: ${escapeHtml(m.status)})</span>` : ""}</div>`).join("") : `<div class="row meta">No minutes metadata loaded.</div>`}
                  ${minutesRows.length > topMinutes.length ? `<div class="row meta">...and ${minutesRows.length - topMinutes.length} more minute document(s)</div>` : ""}
                </div>
              </div>
            </div>
          `;
        })();
        blocks.push(`
          <div class="focus-snapshot-card">
            <div class="focus-snapshot-title">${escapeHtml(title)}</div>
            <div class="focus-snapshot-meta">${escapeHtml(metaBits.join(" â€¢ ") || "Meeting metadata loaded from stored records / contextual results.")}</div>
            <div class="focus-card-stats">${stats.map((s) => `<span class="focus-stat">${escapeHtml(s)}</span>`).join("")}</div>
            <div class="focus-snapshot-actions">
              <button type="button" data-snapshot-preview-toggle="1">${focusSnapshotMeetingPreviewCollapsed ? "Show Focused Meeting Preview" : "Hide Focused Meeting Preview"}</button>
              <button type="button" data-snapshot-meeting-toggle="1">${meetingDetailCollapsed ? "Expand Full Meeting Detail" : "Collapse Full Meeting Detail"}</button>
              <button type="button" data-snapshot-jump-detail="1">Jump To Full Meeting Detail</button>
            </div>
            ${previewHtml}
          </div>
        `);
      } else if (hasEntity && selectedEntityContext) {
        const kindMetaSummary = summarizeKindMetadataForFocus(selectedEntityContext.entityType || "", selectedEntityContext.kindMetadata || {});
        const bindings = Array.isArray(selectedEntityContext.bindings) ? selectedEntityContext.bindings : [];
        const bindingSummary = bindings.slice(0, 2).map((b) => `${b.source_table}:${b.source_id}`).join(" â€¢ ");
        const mentionCount = Number(lastEntityMentionsEntity?.mention_count || 0);
        const relatedCount = Array.isArray(lastEntityRelatedRows) ? lastEntityRelatedRows.length : 0;
        const stats = [
          selectedEntityContext.entityType || "entity",
          mentionCount ? `mentions: ${mentionCount}` : null,
          relatedCount ? `related: ${relatedCount}` : null,
          bindingSummary ? `bindings: ${bindingSummary}` : null,
        ].filter(Boolean);
        blocks.push(`
          <div class="focus-snapshot-card">
            <div class="focus-snapshot-title">${escapeHtml(selectedEntityContext.label || "Entity")}</div>
            <div class="focus-snapshot-meta">${escapeHtml(kindMetaSummary.metaLine || (bindingSummary ? `Bound to ${bindingSummary}` : "Entity focus drives contextual evidence and connections."))}</div>
            <div class="focus-card-stats">${stats.map((s) => `<span class="focus-stat">${escapeHtml(s)}</span>`).join("")}</div>
          </div>
        `);
      }

      if (hasConnection && selectedConnectionContext) {
        const arrow = selectedConnectionContext.direction === "outgoing" ? "â†’" : "â†";
        const stats = [];
        if (Number.isFinite(Number(selectedConnectionContext.evidenceCount))) stats.push(`evidence: ${Number(selectedConnectionContext.evidenceCount)}`);
        if (Number.isFinite(Number(selectedConnectionContext.sharedMeetingCount))) stats.push(`shared meetings: ${Number(selectedConnectionContext.sharedMeetingCount)}`);
        if (Number.isFinite(Number(selectedConnectionContext.edgeCount))) stats.push(`edges: ${Number(selectedConnectionContext.edgeCount)}`);
        blocks.push(`
          <div class="focus-snapshot-card">
            <div class="focus-snapshot-connection">
              <div class="label">Selected Connection</div>
              <div class="focus-snapshot-meta">${escapeHtml(`${selectedConnectionContext.fromLabel} ${arrow} ${selectedConnectionContext.toLabel} (${selectedConnectionContext.relationType})`)}</div>
              <div class="focus-card-stats">${stats.map((s) => `<span class="focus-stat">${escapeHtml(s)}</span>`).join("")}</div>
            </div>
          </div>
        `);
      }

      pinnedFocusSnapshotBodyEl.innerHTML = blocks.join("");
      syncWorkspaceHeight();
    }

    function clearCurrentFocusState({ clearFocusFilters = true } = {}) {
      clearSelectedConnection({ preserveEvidencePanel: false });
      selectedEntityContext = { entityId: null, label: "", entityType: "", bindings: [], kindMetadata: {} };
      selectedMeetingContext = null;
      selectedContextMeetingId = null;
      lastConnectionFocus = null;
      lastEntityRelatedRows = [];
      entityRelatedResultsEl.innerHTML = "";
      entityMentionsResultsEl.innerHTML = "";
      renderLeftEntityContext();
      if (clearFocusFilters) {
        setGlobalEntityFilter("");
        setGlobalMeetingFilter(null);
      }
      if (clearFocusFilters) {
        entitySearchResultsEl.innerHTML = "";
        meetingSearchResultsEl.innerHTML = "";
        contentSearchResultsEl.innerHTML = "";
        renderTopSearchPreview(lastEntitySearchRows);
        void loadStoredMeetingsBrowse();
      }
      clearSelectedMeetingDetailView();
      updateExplorationWorkspaceVisibility();
      updateResultsContextHeader();
      if (activeMainView === "graph") clearGraphWalkState();
      syncWorkspaceHeight();
    }

    function setSelectedEntityContext(entity) {
      const next = {
        entityId: entity?.entityId ? Number(entity.entityId) : null,
        label: (entity?.label || "").trim(),
        entityType: (entity?.entityType || "").trim(),
        bindings: Array.isArray(entity?.bindings) ? entity.bindings : [],
        kindMetadata: (entity?.kindMetadata && typeof entity.kindMetadata === "object") ? entity.kindMetadata : {},
      };
      const changedFocus = focusKeyForEntity(next) !== focusKeyForEntity(selectedEntityContext);
      selectedMeetingContext = null;
      if (changedFocus) clearSelectedConnection({ preserveEvidencePanel: true });
      selectedEntityContext = {
        ...next,
      };
      if (selectedEntityContext.entityId && selectedEntityContext.label) {
        pushRecentFocus({
          kind: "entity",
          id: selectedEntityContext.entityId,
          label: selectedEntityContext.label,
          entityType: selectedEntityContext.entityType,
          normalized: entity?.normalized || "",
          bindings: selectedEntityContext.bindings,
          kindMetadata: selectedEntityContext.kindMetadata,
        });
      }
      clearSelectedMeetingDetailView();
      renderLeftEntityContext();
      updateResultsContextHeader();
    }

    function setSelectedMeetingContext(meeting) {
      const nextMeeting = meeting ? {
        meetingId: Number(meeting.meetingId),
        name: (meeting.name || "").trim(),
        location: (meeting.location || "").trim(),
        time: (meeting.time || "").trim(),
        agendaItemCount: Number(meeting.agendaItemCount || 0),
        documentCount: Number(meeting.documentCount || 0),
        entityCount: Number(meeting.entityCount || 0),
        minutesCount: Number(meeting.minutesCount || 0),
      } : null;
      const changedFocus = focusKeyForMeeting(nextMeeting) !== focusKeyForMeeting(selectedMeetingContext);
      if (changedFocus) clearSelectedConnection({ preserveEvidencePanel: true });
      selectedMeetingContext = nextMeeting;
      if (changedFocus && activeMainView === "graph") {
        lastConnectionFocus = null;
        renderGraphWalk();
      }
      selectedEntityContext = { entityId: null, label: "", entityType: "", bindings: [], kindMetadata: {} };
      if (selectedMeetingContext && selectedMeetingContext.meetingId) {
        pushRecentFocus({
          kind: "meeting",
          id: selectedMeetingContext.meetingId,
          label: selectedMeetingContext.name
            ? `Meeting ${selectedMeetingContext.meetingId} â€¢ ${selectedMeetingContext.name}`
            : `Meeting ${selectedMeetingContext.meetingId}`,
          entityType: "meeting",
          normalized: `meeting:${selectedMeetingContext.meetingId}`,
          bindings: [{ source_table: "meetings", source_id: selectedMeetingContext.meetingId }],
          kindMetadata: {
            name: selectedMeetingContext.name || "",
            location: selectedMeetingContext.location || "",
            time: selectedMeetingContext.time || "",
          },
        });
      }
      renderLeftEntityContext();
      updateResultsContextHeader();
      if (selectedMeetingContext && selectedMeetingContext.meetingId) {
        void loadMeetingFocusConnections(selectedMeetingContext.meetingId);
      }
    }

    function renderLeftEntityContext() {
      if (!(entityContextPanelEl instanceof HTMLElement)) return;
      const hasConnection = Boolean(
        selectedConnectionContext &&
        selectedConnectionContext.fromLabel &&
        selectedConnectionContext.toLabel
      );
      const hasEntity = Boolean(selectedEntityContext.label || (lastEntityMentionsEntity && lastEntityMentionsEntity.display_value));
      const label = selectedEntityContext.label || lastEntityMentionsEntity?.display_value || "";
      const entityType = selectedEntityContext.entityType || lastEntityMentionsEntity?.entity_type || "";
      const hasMeeting = Boolean(selectedMeetingContext && selectedMeetingContext.meetingId);
      const hasFilters = Boolean(globalFilters.topic || globalFilters.entityQuery || globalFilters.entityType || globalFilters.meetingId);
      updateConnectionsMeetingsTitle();

      if (!hasEntity && !hasMeeting && !hasConnection) {
        entityContextPanelEl.hidden = true;
        if (topFocusPanelEl instanceof HTMLElement) {
          topFocusPanelEl.hidden = !hasFilters;
        }
        if (clearCurrentFocusBtn instanceof HTMLElement) clearCurrentFocusBtn.hidden = true;
        if (focusDetailsCardEl instanceof HTMLElement) {
          if (hasFilters) {
            const filterBits = [
              globalFilters.meetingId ? `meeting ${globalFilters.meetingId}` : null,
              globalFilters.entityQuery ? `entity "${globalFilters.entityQuery}"` : null,
              globalFilters.entityType ? `kind ${globalFilters.entityType}` : null,
              globalFilters.topic ? `topic "${globalFilters.topic}"` : null,
            ].filter(Boolean);
            focusDetailsCardEl.innerHTML = `
              <div class="focus-card-title">No Active Focus Selected</div>
              <div class="focus-card-meta">${filterBits.length ? `Filters are active for ${filterBits.join(" â€¢ ")}.` : "Choose an entity or meeting to set focus."}</div>
              <div class="focus-card-stats"><span class="focus-stat">filter-only mode</span><span class="focus-stat">search or click to focus</span></div>
            `;
          } else {
            focusDetailsCardEl.innerHTML = "";
          }
        }
        if (entityContextSummaryEl instanceof HTMLElement) {
          entityContextSummaryEl.textContent = hasFilters ? "Filter Context (No Focus)" : "No item selected.";
        }
        renderTopSelectedConnectionCard();
        if (entityContextTitleEl instanceof HTMLElement) entityContextTitleEl.textContent = "Focused Entity Mentions";
        if (entityContextSubEl instanceof HTMLElement) entityContextSubEl.textContent = "Quick mention preview for the currently selected entity.";
        if (entityContextBodyTitleEl instanceof HTMLElement) entityContextBodyTitleEl.textContent = "Mentions / Evidence";
        leftEntityMentionsEl.innerHTML = "";
        if (relatedEntitiesWorkspacePanelEl instanceof HTMLElement) relatedEntitiesWorkspacePanelEl.hidden = true;
        if (leftRelatedEmptyEl instanceof HTMLElement) leftRelatedEmptyEl.hidden = false;
        updateDiscoveryStartsVisibility();
        renderPinnedFocusSnapshot();
        updateEvidencePanelMode();
        return;
      }

      entityContextPanelEl.hidden = !(hasEntity || hasConnection);
      if (topFocusPanelEl instanceof HTMLElement) topFocusPanelEl.hidden = false;
      if (clearCurrentFocusBtn instanceof HTMLElement) clearCurrentFocusBtn.hidden = !(hasEntity || hasMeeting);
      if (relatedEntitiesWorkspacePanelEl instanceof HTMLElement) relatedEntitiesWorkspacePanelEl.hidden = false;
      updateDiscoveryStartsVisibility();
      if (hasMeeting && selectedMeetingContext) {
        entityContextSummaryEl.textContent = `Meeting ${selectedMeetingContext.meetingId}`;
        if (focusDetailsCardEl instanceof HTMLElement) {
          const title = selectedMeetingContext.name
            ? `Meeting ${selectedMeetingContext.meetingId} â€¢ ${selectedMeetingContext.name}`
            : `Meeting ${selectedMeetingContext.meetingId}`;
          const metaBits = [selectedMeetingContext.location, selectedMeetingContext.time].filter(Boolean);
          const stats = [
            `agenda: ${selectedMeetingContext.agendaItemCount}`,
            `docs: ${selectedMeetingContext.documentCount}`,
            `entities: ${selectedMeetingContext.entityCount}`,
            `minutes: ${selectedMeetingContext.minutesCount}`,
          ];
          focusDetailsCardEl.innerHTML = `
            <div class="focus-card-title">${title}</div>
            <div class="focus-card-meta">${metaBits.join(" â€¢ ") || "Meeting metadata loaded from stored records / contextual results."}</div>
            <div class="focus-card-stats">${stats.map((s) => `<span class="focus-stat">${s}</span>`).join("")}</div>
          `;
        }
        renderTopSelectedConnectionCard();
      } else {
        entityContextSummaryEl.textContent = entityType ? `${label} (${entityType})` : label;
        if (focusDetailsCardEl instanceof HTMLElement) {
          const mentionCount = Number(lastEntityMentionsEntity?.mention_count || 0);
          const relatedCount = Array.isArray(lastEntityRelatedRows) ? lastEntityRelatedRows.length : 0;
          const bindings = Array.isArray(selectedEntityContext.bindings) && selectedEntityContext.bindings.length
            ? selectedEntityContext.bindings
            : (Array.isArray(lastEntityMentionsEntity?.bindings) ? lastEntityMentionsEntity.bindings : []);
          const bindingSummary = bindings.slice(0, 2).map((b) => `${b.source_table}:${b.source_id}`).join(" â€¢ ");
          const kindMeta = (selectedEntityContext.kindMetadata && typeof selectedEntityContext.kindMetadata === "object")
            ? selectedEntityContext.kindMetadata
            : {};
          const kindMetaSummary = summarizeKindMetadataForFocus(entityType, kindMeta);
          const stats = [
            entityType || "entity",
            mentionCount ? `mentions: ${mentionCount}` : null,
            relatedCount ? `related: ${relatedCount}` : null,
            bindingSummary ? `bindings: ${bindingSummary}` : null,
            ...(kindMetaSummary.extraStats || []),
          ].filter(Boolean);
          focusDetailsCardEl.innerHTML = `
            <div class="focus-card-title">${label || "Entity"}</div>
            <div class="focus-card-meta">${kindMetaSummary.metaLine || (bindingSummary ? `Bound to source records (${bindingSummary}).` : "Entity focus drives contextual meeting and document evidence below.")}</div>
            <div class="focus-card-stats">${stats.map((s) => `<span class="focus-stat">${s}</span>`).join("")}</div>
          `;
        }
        renderTopSelectedConnectionCard();
      }

      if (hasConnection && selectedConnectionContext) {
        if (entityContextTitleEl instanceof HTMLElement) entityContextTitleEl.textContent = "Connection Details";
        if (entityContextSubEl instanceof HTMLElement) {
          const arrow = selectedConnectionContext.direction === "outgoing" ? "â†’" : "â†";
          entityContextSubEl.textContent = `${selectedConnectionContext.fromLabel} ${arrow} ${selectedConnectionContext.toLabel} (${selectedConnectionContext.relationType})`;
        }
        if (entityContextBodyTitleEl instanceof HTMLElement) entityContextBodyTitleEl.textContent = "Connection Evidence Preview";
        const rows = (selectedConnectionContext.rows || []).slice(0, 8);
        if (!rows.length) {
          leftEntityMentionsEl.classList.remove("compact");
          leftEntityMentionsEl.innerHTML = `<div class="entity-context-empty">No evidence preview available for the selected connection.</div>`;
        } else {
          leftEntityMentionsEl.classList.add("compact");
          leftEntityMentionsEl.innerHTML = rows.map((m) => (
            `<div class="context-row"><div class="meta">meeting ${m.meeting_id ?? "?"} â€¢ ${m.evidence_source_type}:${m.evidence_source_id} â€¢ strength: ${Number(m.strength || 0).toFixed(2)}</div>${m.mention_text ? `<div class="meta">mention: ${m.mention_text}</div>` : ""}<div class="mention-context">${m.context_text || "(no context)"}</div></div>`
          )).join("");
        }
        renderPinnedFocusSnapshot();
        updateEvidencePanelMode();
        syncWorkspaceHeight();
        return;
      }

      if (entityContextTitleEl instanceof HTMLElement) entityContextTitleEl.textContent = "Focused Entity Mentions";
      if (entityContextSubEl instanceof HTMLElement) entityContextSubEl.textContent = "Quick mention preview for the currently selected entity.";
      if (entityContextBodyTitleEl instanceof HTMLElement) entityContextBodyTitleEl.textContent = "Mentions / Evidence";
      const mentions = (lastEntityMentionsEntity?.mentions || []).slice(0, 12);
      if (!hasEntity || !mentions.length) {
        leftEntityMentionsEl.classList.remove("compact");
        leftEntityMentionsEl.innerHTML = `<div class="entity-context-empty">Select an entity mention count or result to load mention context.</div>`;
      } else {
        leftEntityMentionsEl.classList.add("compact");
        leftEntityMentionsEl.innerHTML = mentions.map((m) => (
          `<div class="context-row"><div class="meta">meeting ${m.meeting_id} â€¢ ${m.source_type} â€¢ confidence: ${Number(m.confidence || 0).toFixed(2)}</div><div class="mention-context">${m.context_text || m.mention_text || "(no context)"}</div></div>`
        )).join("");
      }
      renderPinnedFocusSnapshot();
      updateEvidencePanelMode();
      syncWorkspaceHeight();
    }

    function setProgress(processed, discovered) {
      if (!discovered) {
        progressBar.style.width = "0%";
        return;
      }
      const pct = Math.max(0, Math.min(100, Math.round((processed / discovered) * 100)));
      progressBar.style.width = `${pct}%`;
    }

    function renderCoverageStats(payload) {
      if (!payload) {
        coverageStatsEl.innerHTML = "";
        recentRangesEl.innerHTML = "";
        return;
      }
      const cards = [
        ["Meetings", payload.meeting_count || 0],
        ["Agenda Items", payload.agenda_item_count || 0],
        ["Documents", payload.document_count || 0],
        ["Minutes", payload.minutes_metadata_count || 0],
        ["Entities", payload.entity_count || 0],
      ];
      coverageStatsEl.innerHTML = cards
        .map(([k, v]) => `<div class="coverage-kpi"><div class="k">${k}</div><div class="v">${v}</div></div>`)
        .join("");

      const rows = payload.recent_discovery_ranges || [];
      if (!rows.length) {
        recentRangesEl.innerHTML = `<div class="range-row">No cached discovery ranges yet. Run ingest to build coverage history.</div>`;
        return;
      }
      recentRangesEl.innerHTML = rows.map((r) => (
        `<div class="range-row"><button type="button" data-apply-range="1" data-range-from="${r.from_date}" data-range-to="${r.to_date}" data-range-chunk="${r.chunk_days}" data-range-crawl="${String(Boolean(r.crawl))}">${r.from_date} to ${r.to_date}</button><div class="meta">${r.discovered_count} meetings â€¢ ${r.crawl ? "crawl" : "single call"} â€¢ chunk ${r.chunk_days}</div><div class="meta">fetched: ${r.last_fetched_at || "unknown"}</div></div>`
      )).join("");
    }

    function renderGraphDiagnostics(payload) {
      if (!(runtimePanelEl instanceof HTMLElement)) return;
      if (!payload) {
        runtimePanelEl.innerHTML = `<div class="meta">Graph summary unavailable.</div>`;
        return;
      }
      const totalEntities = Number(payload.entity_count || 0);
      const totalConnections = Number(payload.connection_count || 0);
      const typeRows = Array.isArray(payload.entity_type_counts) ? payload.entity_type_counts : [];
      const topTypes = typeRows.slice(0, 8);
      runtimePanelEl.innerHTML = `
        <div><strong>Graph Summary</strong></div>
        <div class="meta">entities: ${totalEntities} â€¢ connections: ${totalConnections}</div>
        <div class="entity-list" style="margin-top:4px;">
          ${topTypes.length
            ? topTypes.map((t) => `<span class="focus-stat">${t.entity_type}: ${t.count}</span>`).join("")
            : `<span class="meta">No entity types yet.</span>`}
        </div>
      `;
    }

    function renderRangeCacheStatus(payload) {
      if (!payload) {
        rangeCacheStatusEl.textContent = "Cache status unavailable.";
        return;
      }
      if (!payload.has_cache) {
        rangeCacheStatusEl.innerHTML = `No cached discovery list for this date range and crawl mode. The next run will query CivicWeb and save coverage.`;
        return;
      }
      const freshness = payload.cache_fresh
        ? "<span class='runtime-ok'>fresh cache available</span>"
        : "<span class='runtime-warn'>cache expired</span>";
      rangeCacheStatusEl.innerHTML = `${freshness} â€¢ discovered meetings: ${payload.discovered_count || 0}<br><span class="meta">last fetched: ${payload.last_fetched_at || "unknown"} â€¢ ttl: ${payload.cache_ttl_minutes} min</span>`;
    }

    function renderStoredMeetingsBrowse(rows) {
      if (!rows || !rows.length) {
        storedMeetingsListEl.innerHTML = `<div class="browse-row">No stored meetings match the current filters.</div>`;
        syncWorkspaceHeight();
        return;
      }
      storedMeetingsListEl.innerHTML = rows.map((m) => (
        `<div class="browse-row ${selectedStoredMeetingId === Number(m.meeting_id) ? "active" : ""}"><button type="button" data-open-meeting-id="${m.meeting_id}" data-meeting-name="${(m.name || "").replace(/"/g, "&quot;")}" data-meeting-location="${(m.location || "").replace(/"/g, "&quot;")}" data-meeting-time="${(m.time || "").replace(/"/g, "&quot;")}" data-meeting-agenda-count="${m.agenda_item_count || 0}" data-meeting-document-count="${m.document_count || 0}" data-meeting-entity-count="${m.entity_count || 0}" data-meeting-minutes-count="${m.minutes_count || 0}">Meeting ${m.meeting_id}${m.name ? ` â€¢ ${m.name}` : ""}</button><div class="meta">${m.location || "location unknown"} ${m.time ? `â€¢ ${m.time}` : ""}</div><div class="meta">agenda: ${m.agenda_item_count} â€¢ docs: ${m.document_count} â€¢ entities: ${m.entity_count}${m.matched_topic_count ? ` â€¢ topic matches: ${m.matched_topic_count}` : ""}</div></div>`
      )).join("");
      syncWorkspaceHeight();
    }

    function renderTopicBrowser(rows) {
      if (!rows || !rows.length) {
        topicBrowserListEl.innerHTML = `<div class="browse-row">No topics available from stored agenda data yet.</div>`;
        syncWorkspaceHeight();
        return;
      }
      topicBrowserListEl.innerHTML = rows.map((t) => (
        `<div class="browse-row ${globalFilters.topic === t.topic ? "active" : ""}"><button type="button" data-topic-browser="${t.topic}">${t.topic}</button><div class="meta">agenda items: ${t.agenda_item_count} â€¢ meetings: ${t.meeting_count}${(t.recent_meeting_ids || []).length ? ` â€¢ recent: ${(t.recent_meeting_ids || []).join(", ")}` : ""}</div></div>`
      )).join("");
      syncWorkspaceHeight();
    }

    function renderMeetingSearchResults(rows) {
      const entityType = (globalFilters.entityType || "").trim();
      if (entityType && entityType !== "meeting") {
        meetingSearchResultsEl.innerHTML = `<div class="search-subtitle">Stored Meeting Matches (Convenience)</div><div class="search-result">Hidden while node type filter is set to <strong>${entityType}</strong>.</div>`;
        updateExplorationWorkspaceVisibility();
        syncWorkspaceHeight();
        return;
      }
      if (!rows || !rows.length) {
        meetingSearchResultsEl.innerHTML = `<div class="search-subtitle">Stored Meeting Matches (Convenience)</div><div class="search-result">No meeting matches.</div>`;
        updateExplorationWorkspaceVisibility();
        syncWorkspaceHeight();
        return;
      }
      meetingSearchResultsEl.innerHTML =
        `<div class="search-subtitle">Stored Meeting Matches (Convenience)</div>` +
        rows.map((m) => (
          `<div class="search-result"><button type="button" data-open-meeting-id="${m.meeting_id}" data-meeting-name="${(m.name || "").replace(/"/g, "&quot;")}" data-meeting-location="${(m.location || "").replace(/"/g, "&quot;")}" data-meeting-time="${(m.time || "").replace(/"/g, "&quot;")}" data-meeting-agenda-count="${m.agenda_item_count || 0}" data-meeting-document-count="${m.document_count || 0}" data-meeting-entity-count="${m.entity_count || 0}" data-meeting-minutes-count="${m.minutes_count || 0}">Meeting ${m.meeting_id}${m.name ? ` â€¢ ${m.name}` : ""}</button><div class="meta">${m.location || "location unknown"} ${m.time ? `â€¢ ${m.time}` : ""}</div><div class="meta">agenda: ${m.agenda_item_count} â€¢ docs: ${m.document_count} â€¢ entities: ${m.entity_count}</div></div>`
        )).join("");
      updateExplorationWorkspaceVisibility();
      syncWorkspaceHeight();
    }

    function renderSignals(signals) {
      if (!signals) return "";
      const pairs = Object.entries(signals).filter(([, v]) => v);
      if (!pairs.length) return "";
      return `<div class="signals">${pairs.map(([k, v]) => `${k}: ${v}`).join(" | ")}</div>`;
    }

    function topicChip(topic, activeTopic) {
      const active = topic === activeTopic ? "active" : "";
      return `<button type="button" class="chip ${active}" data-topic="${topic}">${topic}</button>`;
    }

    function renderItem(item, activeTopic) {
      const topics = item.topics || [];
      const docs = item.documents || [];
      return `
        <div class="item">
          <strong>${item.item_key}</strong> ${item.title}
          <div class="topic-row">${topics.map((t) => topicChip(t, activeTopic)).join("") || ""}</div>
          ${docs.length ? `<div class="doc-list">${docs.map((d) => `<a class="doc-link" href="${d.url}" target="_blank" rel="noreferrer">${d.title || `document ${d.document_id}`}</a>`).join("")}</div>` : ""}
          ${renderSignals(item.zoning_signals)}
        </div>
      `;
    }

    function renderMinutes(metadataRows) {
      if (!metadataRows || !metadataRows.length) return "";
      return `
        <div class="minutes">
          <div class="minutes-title">Extracted Minutes Metadata</div>
          ${metadataRows
            .map((m) => {
              const bits = [];
              if (m.detected_date) bits.push(`date: ${m.detected_date}`);
              if (Number.isInteger(m.page_count)) bits.push(`pages: ${m.page_count}`);
              if (m.status) bits.push(`status: ${m.status}`);
              return `<div class="minutes-row"><a href="${m.url}" target="_blank" rel="noreferrer">${m.title || `document ${m.document_id}`}</a>${bits.length ? ` (${bits.join(" | ")})` : ""}</div>`;
            })
            .join("")}
        </div>
      `;
    }

    function renderEntitySummaryInline(entities) {
      if (!entities || !entities.length) return "";
      const top = entities.slice(0, 12);
      return `
        <div class="entity-panel">
          <div class="entity-title">Entities in this meeting</div>
          <div class="entity-list">
            ${top.map((e) => `<button type="button" class="entity-chip ${globalFilters.entityQuery === e.display_value ? "active" : ""}" data-entity-query="${e.display_value}">${e.display_value} (${e.entity_type})</button>`).join("")}
          </div>
        </div>
      `;
    }

    function renderMeetingDocumentSummary(items) {
      const docs = [];
      const seen = new Set();
      for (const item of items || []) {
        for (const d of (item.documents || [])) {
          const key = `${d.document_id}:${d.url}`;
          if (seen.has(key)) continue;
          seen.add(key);
          docs.push(d);
        }
      }
      if (!docs.length) return "";
      const top = docs.slice(0, 8);
      return `
        <div class="minutes">
          <div class="minutes-title">Documents Retrieved (${docs.length})</div>
          ${top.map((d) => `<div class="minutes-row"><a href="${d.url}" target="_blank" rel="noreferrer">${d.title || `document ${d.document_id}`}</a></div>`).join("")}
        </div>
      `;
    }

    function renderMeeting(meetingId, items, minutesMetadata, entities, activeTopic) {
      return `
        <article class="meeting">
          <h3>Meeting ${meetingId}</h3>
          <div class="meta">${items.length} matching agenda item(s)</div>
          ${renderEntitySummaryInline(entities)}
          ${renderMeetingDocumentSummary(items)}
          ${renderMinutes(minutesMetadata)}
          ${items.map((item) => renderItem(item, activeTopic)).join("") || "<div class=\"meta\">No matching agenda items.</div>"}
        </article>
      `;
    }

    function renderContextualMeetingList(meetingResults, activeTopic) {
      if (!(meetingResultsListEl instanceof HTMLElement)) return;
      updateConnectionsMeetingsTitle();
      let rowsToRender = [...(meetingResults || [])];
      const meetingFocused = Boolean(selectedMeetingContext && selectedMeetingContext.meetingId);
      const entityFocused = Boolean(selectedEntityContext && selectedEntityContext.label);
      if (meetingFocused && !entityFocused) {
        rowsToRender = rowsToRender.filter((r) => Number(r.meetingId) !== Number(selectedMeetingContext.meetingId));
      }
      if (!rowsToRender.length) {
        meetingResultsListEl.innerHTML = `<div class="browse-row">${(meetingFocused && !entityFocused) ? "No other meetings match the current filter context." : "No meetings match the current context."}</div>`;
        return;
      }
      meetingResultsListEl.innerHTML = rowsToRender.map((r) => {
        const docCount = (() => {
          const seen = new Set();
          for (const item of (r.agendaItems || [])) {
            for (const d of (item.documents || [])) seen.add(`${d.document_id}:${d.url}`);
          }
          return seen.size;
        })();
        const minutesCount = (r.minutesMetadata || []).length;
        const entityCount = (r.entities || []).length;
        const active = Number(r.meetingId) === Number(selectedContextMeetingId);
        return `
          <div class="meeting-list-row ${active ? "active" : ""}">
            <button type="button" data-select-context-meeting-id="${r.meetingId}">Meeting ${r.meetingId}</button>
            <div class="meta">${(r.agendaItems || []).length} matching agenda item(s)${activeTopic ? ` for topic "${activeTopic}"` : ""}</div>
            <div class="meeting-list-stats">
              <span>agenda: ${(r.agendaItems || []).length}</span>
              <span>docs: ${docCount}</span>
              <span>entities: ${entityCount}</span>
              <span>minutes: ${minutesCount}</span>
            </div>
          </div>
        `;
      }).join("");
    }

    function renderSelectedMeetingDetail(meetingResults, activeTopic) {
      const selected = meetingResults.find((r) => Number(r.meetingId) === Number(selectedContextMeetingId)) || null;
      if (!(meetingDetailTitleEl instanceof HTMLElement) || !(meetingDetailSubEl instanceof HTMLElement)) return;
      if (!selected) {
        meetingDetailTitleEl.textContent = "Selected Meeting Detail";
        meetingDetailSubEl.textContent = "Choose a meeting from the contextual list.";
        resultsEl.innerHTML = `<article class="meeting"><div class="meta">No meeting selected.</div></article>`;
        return;
      }
      const agendaCount = (selected.agendaItems || []).length;
      meetingDetailTitleEl.textContent = `Meeting ${selected.meetingId}`;
      meetingDetailSubEl.textContent = `${agendaCount} matching agenda item(s)${activeTopic ? ` â€¢ topic "${activeTopic}"` : ""}`;
      resultsEl.innerHTML = renderMeeting(
        selected.meetingId,
        selected.agendaItems || [],
        selected.minutesMetadata || [],
        selected.entities || [],
        activeTopic
      );
    }

    function renderRelatedTopics(meetingResults, activeTopic) {
      if (!activeTopic) {
        relatedEl.hidden = true;
        return;
      }

      const counts = new Map();
      for (const r of meetingResults) {
        for (const item of r.agendaItems) {
          for (const t of item.topics || []) {
            if (t === activeTopic) continue;
            counts.set(t, (counts.get(t) || 0) + 1);
          }
        }
      }

      const ranked = [...counts.entries()].sort((a, b) => b[1] - a[1]).slice(0, 10);
      if (!ranked.length) {
        relatedEl.hidden = false;
        relatedEl.textContent = `No related topics found for ${activeTopic}.`;
        return;
      }

      relatedEl.hidden = false;
      relatedEl.innerHTML = `Related to <strong>${activeTopic}</strong>: ${ranked
        .map(([topic, count]) => `<button type="button" class="chip" data-topic="${topic}">${topic} (${count})</button>`)
        .join(" ")}`;
    }

    async function startIngestJob(params) {
      const response = await fetch(`/ingest/range/job?${params.toString()}`, { method: "POST" });
      if (!response.ok) throw new Error(`Unable to start ingest job (${response.status})`);
      return response.json();
    }

    async function pollJob(jobId) {
      while (true) {
        const response = await fetch(`/ingest/range/job/${jobId}`);
        if (!response.ok) throw new Error(`Unable to fetch job status (${response.status})`);
        const job = await response.json();
        const progress = job.progress || {};
        const discovered = Number(progress.discovered || 0);
        const processed = Number(progress.processed || 0);
        setProgress(processed, discovered);

        const currentMeeting = progress.current_meeting_id ? ` (meeting ${progress.current_meeting_id})` : "";
        const discoveryBits = progress.discovery_source ? ` â€¢ discovery: ${progress.discovery_source}` : "";
        if (job.status === "running" || job.status === "queued") {
          setIngestStatus(`Ingest progress: ${processed}/${discovered || "?"}${currentMeeting}${discoveryBits}`);
          await new Promise((resolve) => setTimeout(resolve, 900));
          continue;
        }

        if (job.status === "failed") {
          throw new Error(job.error || "Ingest job failed.");
        }

        return job.result;
      }
    }

    async function loadAgendaForMeetings(meetingIds, topic) {
      const out = [];
      let total = 0;

      for (let i = 0; i < meetingIds.length; i += 1) {
        const meetingId = meetingIds[i];
        setIngestStatus(`Loading agenda ${i + 1}/${meetingIds.length} (meeting ${meetingId})...`);

        const agendaParams = new URLSearchParams();
        if (topic) agendaParams.set("topic", topic);

        const agendaRes = await fetch(`/meetings/${meetingId}/agenda?${agendaParams.toString()}`);
        if (!agendaRes.ok) continue;

        const agendaItems = await agendaRes.json();
        if (agendaItems.length || !topic) {
          let minutesMetadata = [];
          const minutesRes = await fetch(`/meetings/${meetingId}/minutes-metadata`);
          if (minutesRes.ok) {
            minutesMetadata = await minutesRes.json();
          }

          let entities = [];
          const entitiesRes = await fetch(`/meetings/${meetingId}/entities?limit=50`);
          if (entitiesRes.ok) {
            entities = await entitiesRes.json();
          }

          out.push({ meetingId, agendaItems, minutesMetadata, entities });
          total += agendaItems.length;
        }
      }

      return { meetingResults: out, totalItems: total };
    }

    function renderResults(meetingResults, activeTopic) {
      if (!meetingResults.length) {
        selectedContextMeetingId = null;
        if (meetingResultsListEl instanceof HTMLElement) {
          meetingResultsListEl.innerHTML = `<div class="browse-row">No meetings had matching agenda items for this topic.</div>`;
        }
        if (meetingDetailTitleEl instanceof HTMLElement) meetingDetailTitleEl.textContent = "Selected Meeting Detail";
        if (meetingDetailSubEl instanceof HTMLElement) meetingDetailSubEl.textContent = "No matching meetings for the current context.";
        resultsEl.innerHTML = `<article class="meeting"><div class="meta">No meetings had matching agenda items for this topic.</div></article>`;
      } else {
        const hasSelected = meetingResults.some((r) => Number(r.meetingId) === Number(selectedContextMeetingId));
        if (!hasSelected) {
          selectedContextMeetingId = Number(globalFilters.meetingId || meetingResults[0].meetingId);
        }
        const selected = meetingResults.find((r) => Number(r.meetingId) === Number(selectedContextMeetingId)) || null;
        const entityFocused = Boolean(selectedEntityContext && selectedEntityContext.label);
        const meetingFocused = Boolean(selectedMeetingContext && selectedMeetingContext.meetingId);
        if (selected && !entityFocused && (!meetingFocused || Number(selectedMeetingContext.meetingId) !== Number(selected.meetingId))) {
          const seenDocs = new Set();
          for (const item of (selected.agendaItems || [])) {
            for (const d of (item.documents || [])) seenDocs.add(`${d.document_id}:${d.url}`);
          }
          setSelectedMeetingContext({
            meetingId: selected.meetingId,
            agendaItemCount: (selected.agendaItems || []).length,
            documentCount: seenDocs.size,
            entityCount: (selected.entities || []).length,
            minutesCount: (selected.minutesMetadata || []).length,
          });
        }
        renderContextualMeetingList(meetingResults, activeTopic);
        renderSelectedMeetingDetail(meetingResults, activeTopic);
      }
      renderRelatedTopics(meetingResults, activeTopic);
      updateExplorationWorkspaceVisibility();
      syncWorkspaceHeight();
    }

    function summarizeKindMetadataForSearchRow(row) {
      const kind = String(row?.entity_type || "").toLowerCase();
      const meta = (row?.kind_metadata && typeof row.kind_metadata === "object") ? row.kind_metadata : {};
      const pick = (...keys) => keys.map((k) => meta[k]).find((v) => v);
      if (kind === "meeting") {
        const bits = [pick("date"), pick("location"), pick("time")].filter(Boolean);
        return bits.join(" â€¢ ");
      }
      if (kind === "document") {
        const bits = [pick("document_id") ? `doc ${pick("document_id")}` : "", pick("meeting_id") ? `meeting ${pick("meeting_id")}` : ""].filter(Boolean);
        return bits.join(" â€¢ ");
      }
      if (kind === "person") {
        const bits = [pick("full_name"), pick("first_name"), pick("last_name")].filter(Boolean);
        return bits.join(" â€¢ ");
      }
      if (kind === "organization") {
        const bits = [pick("name"), pick("suffix"), pick("aliases") ? `aliases ${pick("aliases")}` : ""].filter(Boolean);
        return bits.join(" â€¢ ");
      }
      if (kind === "address" || kind === "zip_code") {
        const bits = [pick("address"), pick("city"), pick("state"), pick("zip")].filter(Boolean);
        return bits.join(" â€¢ ");
      }
      if (kind === "date") {
        const bits = [pick("date_iso"), pick("label")].filter(Boolean);
        return bits.join(" â€¢ ");
      }
      return "";
    }

    function summarizeKindMetadataForFocus(entityType, kindMeta) {
      const etype = String(entityType || "").toLowerCase();
      const meta = (kindMeta && typeof kindMeta === "object") ? kindMeta : {};
      const get = (k) => (meta[k] ? String(meta[k]) : "");
      if (etype === "meeting") {
        return {
          metaLine: [get("name"), get("location"), get("time")].filter(Boolean).join(" â€¢ "),
          extraStats: [get("date") ? `date: ${get("date")}` : ""].filter(Boolean),
        };
      }
      if (etype === "document") {
        return {
          metaLine: [get("title"), get("meeting_id") ? `meeting ${get("meeting_id")}` : ""].filter(Boolean).join(" â€¢ "),
          extraStats: [get("document_id") ? `doc: ${get("document_id")}` : ""].filter(Boolean),
        };
      }
      if (etype === "person") {
        return {
          metaLine: [get("full_name"), get("aliases") ? `aliases: ${get("aliases")}` : ""].filter(Boolean).join(" â€¢ "),
          extraStats: [],
        };
      }
      if (etype === "organization") {
        return {
          metaLine: [get("name"), get("suffix"), get("aliases") ? `aliases: ${get("aliases")}` : ""].filter(Boolean).join(" â€¢ "),
          extraStats: [],
        };
      }
      if (etype === "address" || etype === "zip_code") {
        const placeBits = [get("address"), [get("city"), get("state"), get("zip")].filter(Boolean).join(" ")].filter(Boolean);
        return { metaLine: placeBits.join(" â€¢ "), extraStats: [] };
      }
      if (etype === "date") {
        return { metaLine: [get("date_iso"), get("label")].filter(Boolean).join(" â€¢ "), extraStats: [] };
      }
      return { metaLine: "", extraStats: [] };
    }

    function summarizeEdgePreviewForNodeResult(row) {
      if (!row || !Array.isArray(lastEntityRelatedRows) || !lastEntityRelatedRows.length) return "";
      if (!lastConnectionFocus || !lastConnectionFocus.entityId) return "";
      const matches = lastEntityRelatedRows.filter((r) => Number(r.entity_id) === Number(row.entity_id) && Object.prototype.hasOwnProperty.call(r, "relation_type"));
      if (!matches.length) return "";
      const top = matches.slice(0, 2);
      const chips = top.map((m) => {
        const rel = `${m.direction === "outgoing" ? "â†’" : "â†"} ${m.relation_type}`;
        const ev = Number.isFinite(Number(m.evidence_count)) ? ` â€¢ ev ${Number(m.evidence_count)}` : "";
        return `<span class="node-edge-chip">${rel}${ev}</span>`;
      }).join("");
      const more = matches.length > top.length ? `<span class="node-edge-chip">+${matches.length - top.length} more</span>` : "";
      return `<div class="node-edge-preview"><span class="label">connected to focus</span>${chips}${more}</div>`;
    }

    function escapeHtml(value) {
      return String(value ?? "").replace(/[&<>"]/g, (ch) => ({
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        "\"": "&quot;",
      }[ch]));
    }

    function escapeRegex(value) {
      return String(value || "").replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function evidenceHighlightTerms(...labels) {
      const out = [];
      for (const raw of labels) {
        const label = String(raw || "").trim();
        if (!label) continue;
        out.push(label);
        const tokenCandidates = label.split(/[^A-Za-z0-9]+/g).filter(Boolean);
        const allowTokenFallback = tokenCandidates.length > 0 && tokenCandidates.length <= 4 && label.length <= 40;
        if (!allowTokenFallback) continue;
        for (const token of tokenCandidates) {
          if (token && token.length >= 3) out.push(token);
        }
      }
      return [...new Set(out)];
    }

    function highlightEvidenceSnippet(text, labels = []) {
      const safe = escapeHtml(text || "");
      const terms = evidenceHighlightTerms(...(Array.isArray(labels) ? labels : [labels]));
      if (!safe || !terms.length) return safe;
      const escapedTerms = [...new Set(terms.map((t) => escapeHtml(t)).filter(Boolean))]
        .sort((a, b) => b.length - a.length);
      if (!escapedTerms.length) return safe;
      const re = new RegExp(`(${escapedTerms.map(escapeRegex).join("|")})`, "ig");
      return safe.replace(re, `<span class="context-hit">$1</span>`);
    }

    function formatBindingChips(bindings) {
      const rows = Array.isArray(bindings) ? bindings : [];
      if (!rows.length) return "";
      const labels = rows.slice(0, 4).map((b) => {
        const table = String(b.source_table || "");
        const sourceId = Number(b.source_id || 0);
        if (table === "meetings") return `meeting:${sourceId}`;
        if (table === "documents") return `document:${sourceId}`;
        if (table === "agenda_items") return `agenda_item:${sourceId}`;
        return `${table}:${sourceId}`;
      });
      return `<div class="node-binding-row">${labels.map((s) => `<span class="node-binding-chip">${s}</span>`).join("")}</div>`;
    }

    function renderTopSearchPreview(rows = []) {
      if (!(topSearchPreviewEl instanceof HTMLElement) || !(topSearchPreviewListEl instanceof HTMLElement) || !(topSearchPreviewCountEl instanceof HTMLElement)) {
        return;
      }
      const currentFocusKey = currentFocusHistoryKey();
      const focusHistory = (recentFocusHistory || []).filter((r) => r && r.key && r.key !== currentFocusKey);
      const previewFocusRows = focusHistory.slice(0, 4);
      const q = (entitySearchEl.value || "").trim();
      const fallbackRows = (Array.isArray(rows) ? rows : []).filter((row) => {
        const rowKey = Number(row?.entity_id) ? `entity:${Number(row.entity_id)}` : "";
        return rowKey && rowKey !== currentFocusKey;
      }).slice(0, 3);

      if (!previewFocusRows.length && (!q || !fallbackRows.length)) {
        topSearchPreviewEl.hidden = true;
        topSearchPreviewCountEl.textContent = "";
        topSearchPreviewListEl.innerHTML = "";
        if (topSearchPreviewTitleEl instanceof HTMLElement) topSearchPreviewTitleEl.textContent = "Recent Focuses";
        return;
      }

      const renderRow = (row) => {
        const meetingBinding = (row.bindings || []).find((b) => b.source_table === "meetings");
        const attrs = [
          `type="button"`,
          `data-entity-id="${row.entity_id}"`,
          `data-entity-type="${row.entity_type || ""}"`,
          `data-entity-normalized="${String(row.normalized_value || "").replace(/"/g, "&quot;")}"`,
        ];
        if (meetingBinding && Number.isFinite(Number(meetingBinding.source_id))) {
          attrs.push(`data-entity-meeting-id="${Number(meetingBinding.source_id)}"`);
        }
        const kindMeta = summarizeKindMetadataForSearchRow(row);
        return `
          <div class="top-search-hit">
            <div class="hit-head">
              <button ${attrs.join(" ")}>${escapeHtml(row.display_value || "")}</button>
              <span class="node-result-kind">${escapeHtml(row.entity_type || "")}</span>
            </div>
            ${kindMeta ? `<div class="hit-meta">${escapeHtml(kindMeta)}</div>` : ""}
          </div>
        `;
      };

      const renderFocusHistoryItem = (item) => {
        const attrs = [
          `type="button"`,
          `data-entity-id="${item.id}"`,
          `data-entity-type="${item.entityType || ""}"`,
        ];
        if (item.normalized) attrs.push(`data-entity-normalized="${String(item.normalized).replace(/"/g, "&quot;")}"`);
        const meetingBinding = (item.bindings || []).find((b) => b.source_table === "meetings");
        if (meetingBinding && Number.isFinite(Number(meetingBinding.source_id))) {
          attrs.push(`data-entity-meeting-id="${Number(meetingBinding.source_id)}"`);
        }
        const kindMeta = summarizeKindMetadataForSearchRow({
          entity_type: item.entityType,
          kind_metadata: item.kindMetadata,
          bindings: item.bindings,
        });
        return `
          <div class="top-search-hit">
            <div class="hit-head">
              <button ${attrs.join(" ")}>${escapeHtml(item.label)}</button>
              <span class="node-result-kind">${escapeHtml(item.entityType || item.kind || "entity")}</span>
            </div>
            ${kindMeta ? `<div class="hit-meta">${escapeHtml(kindMeta)}</div>` : ""}
          </div>
        `;
      };

      const usingHistory = previewFocusRows.length > 0;
      if (topSearchPreviewTitleEl instanceof HTMLElement) {
        topSearchPreviewTitleEl.textContent = usingHistory ? "Recent Focuses" : "Recent Search Hits";
      }
      const count = usingHistory ? previewFocusRows.length : fallbackRows.length;
      topSearchPreviewCountEl.textContent = usingHistory
        ? `Showing last ${count} item${count === 1 ? "" : "s"}`
        : `${count} item${count === 1 ? "" : "s"}`;
      topSearchPreviewListEl.innerHTML = usingHistory
        ? previewFocusRows.map(renderFocusHistoryItem).join("")
        : fallbackRows.map(renderRow).join("");
      topSearchPreviewEl.hidden = false;
    }

    function renderEntitySearchResults(rows) {
      lastEntitySearchRows = rows || [];
      renderTopSearchPreview(lastEntitySearchRows);
      if (!rows.length) {
        entitySearchResultsEl.innerHTML = `<div class="search-result">No matching entities found.</div>`;
        updateExplorationWorkspaceVisibility();
        syncWorkspaceHeight();
        return;
      }

      const q = (entitySearchEl.value || "").trim();
      const qRe = q ? new RegExp(`(${q.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&")})`, "ig") : null;
      const highlight = (s) => {
        if (!s) return "";
        if (!qRe) return s;
        return s.replace(qRe, `<span class="context-hit">$1</span>`);
      };
      const sourceLabel = (m) => {
        if (m.source_type === "agenda_item_title") return `agenda item ${m.agenda_item_id ?? "?"}`;
        if (m.source_type === "minutes_excerpt") return `minutes doc ${m.document_id ?? "?"}`;
        if (m.source_type === "document_content") return `document content ${m.document_id ?? "?"}`;
        if (m.source_type === "meeting_metadata") return "meeting metadata";
        return m.source_type;
      };

      entitySearchResultsEl.innerHTML = rows.map((row) => {
        const meetingBinding = (row.bindings || []).find((b) => b.source_table === "meetings");
        const entityAttrs = [
          `data-entity-id="${row.entity_id}"`,
          `data-entity-type="${row.entity_type}"`,
          `data-entity-normalized="${String(row.normalized_value || "").replace(/"/g, "&quot;")}"`,
        ];
        if (meetingBinding && Number.isFinite(Number(meetingBinding.source_id))) {
          entityAttrs.push(`data-entity-meeting-id="${Number(meetingBinding.source_id)}"`);
        }
        const mentionRows = (row.mentions || []).map((m) => {
          const ctx = highlight(m.context_text || m.mention_text || "");
          return `
            <div class="mention-line">
              <div class="mention-meta">
                <span>meeting ${m.meeting_id}</span>
                <span>${sourceLabel(m)}</span>
                <span>confidence: ${Number(m.confidence || 0).toFixed(2)}</span>
              </div>
              <div class="mention-context">${ctx || "(no context)"}</div>
            </div>
          `;
        }).join("");
        const kindMetaLine = summarizeKindMetadataForSearchRow(row);
        const bindingLine = formatBindingChips(row.bindings || []);
        const edgePreview = summarizeEdgePreviewForNodeResult(row);
        return `
          <div class="search-result featured node-result-card">
            <div class="node-result-head">
              <button type="button" ${entityAttrs.join(" ")}>${row.display_value}</button>
              <span class="node-result-kind">${row.entity_type}</span>
              <span class="meta"><a class="meta-link" href="#" data-entity-mentions-id="${row.entity_id}">mentions: ${row.mention_count}</a></span>
            </div>
            ${kindMetaLine ? `<div class="node-result-summary">${kindMetaLine}</div>` : ""}
            ${edgePreview}
            ${bindingLine}
            <div class="mention-list">${mentionRows || "<div class='meta'>No mention preview</div>"}</div>
          </div>
        `;
      }).join("");
      updateExplorationWorkspaceVisibility();
      syncWorkspaceHeight();
    }

    function renderEntityRelatedResults(rows, entityLabel) {
      lastEntityRelatedRows = rows || [];
      if (relatedEntitiesWorkspacePanelEl instanceof HTMLElement) relatedEntitiesWorkspacePanelEl.hidden = false;
      if (leftRelatedEmptyEl instanceof HTMLElement) {
        leftRelatedEmptyEl.hidden = Boolean((rows || []).length);
      }
      if (!rows.length) {
        entityRelatedResultsEl.innerHTML = `<div class="search-result">No related entities found for ${entityLabel}.</div>`;
        renderLeftEntityContext();
        updateExplorationWorkspaceVisibility();
        syncWorkspaceHeight();
        return;
      }
      const hasGraphEdgeShape = rows.some((r) => Object.prototype.hasOwnProperty.call(r, "relation_type"));
      const title = hasGraphEdgeShape ? `Connections for ${entityLabel}` : `Related to ${entityLabel}`;
      entityRelatedResultsEl.innerHTML = `<div class="entity-title">${title}</div>` + rows.map((row) => {
        const attrs = [
          `data-entity-id="${row.entity_id}"`,
          `data-entity-type="${row.entity_type || ""}"`,
          `data-entity-normalized="${String(row.normalized_value || "").replace(/"/g, "&quot;")}"`,
        ];
        const meetingBinding = (row.bindings || []).find((b) => b.source_table === "meetings");
        if (meetingBinding && Number.isFinite(Number(meetingBinding.source_id))) {
          attrs.push(`data-entity-meeting-id="${Number(meetingBinding.source_id)}"`);
        }
        const edgeMeta = hasGraphEdgeShape
          ? `${row.direction} â€¢ ${row.relation_type} â€¢ meetings: ${row.shared_meeting_count} â€¢ evidence: ${row.evidence_count}`
          : `shared meetings: ${row.shared_meeting_count} â€¢ co-occurrences: ${row.cooccurrence_count}`;
        const mentionsAttrs = [
          `data-entity-mentions-id="${row.entity_id}"`,
          `data-entity-mentions-label="${String(row.display_value || "").replace(/"/g, "&quot;")}"`,
        ];
        if (hasGraphEdgeShape) mentionsAttrs.push(`data-entity-mentions-preserve-focus="1"`);
        const links = hasGraphEdgeShape
          ? ` <a class="meta-link" href="#" data-connection-evidence-entity-id="${row.entity_id}" data-connection-relation-type="${String(row.relation_type || "").replace(/"/g, "&quot;")}" data-connection-direction="${String(row.direction || "").replace(/"/g, "&quot;")}">view evidence</a> â€¢ <a class="meta-link" href="#" ${mentionsAttrs.join(" ")}>view mentions</a>`
          : ` <a class="meta-link" href="#" ${mentionsAttrs.join(" ")}>view mentions</a>`;
        const kindMetaLine = summarizeKindMetadataForSearchRow(row);
        const isSelectedEdge = Boolean(
          selectedConnectionContext &&
          Number(selectedConnectionContext.toEntityId) === Number(row.entity_id) &&
          String(selectedConnectionContext.relationType || "") === String(row.relation_type || "") &&
          String(selectedConnectionContext.direction || "") === String(row.direction || "")
        );
        return `<div class="search-result related ${isSelectedEdge ? "active-edge" : ""}"><div class="node-result-head"><button type="button" ${attrs.join(" ")}>${row.display_value}</button> <span class="node-result-kind">${row.entity_type}</span><span class="meta">${edgeMeta} â€¢${links}</span></div>${kindMetaLine ? `<div class="node-result-summary">${kindMetaLine}</div>` : ""}</div>`;
      }).join("");
      renderLeftEntityContext();
      updateExplorationWorkspaceVisibility();
      syncWorkspaceHeight();
    }

    function renderEntityMentionsDetail(entity, options = {}) {
      const preserveFocus = Boolean(options && options.preserveFocus);
      const preserveConnection = Boolean(options && options.preserveConnection);
      const labelHint = String((options && options.labelHint) || "");
      const snippetHighlightLabels = [];
      if (preserveFocus && selectedConnectionContext?.toLabel) snippetHighlightLabels.push(selectedConnectionContext.toLabel);
      if (labelHint) snippetHighlightLabels.push(labelHint);
      if (!preserveFocus && entity?.display_value) snippetHighlightLabels.push(entity.display_value);
      if (!preserveFocus) {
        lastEntityMentionsEntity = entity || null;
      }
      if (!preserveFocus && (entity?.entity_id || entity?.display_value)) {
        setSelectedEntityContext({
          entityId: entity.entity_id,
          label: entity.display_value,
          entityType: entity.entity_type || "",
          bindings: entity.bindings || [],
          kindMetadata: entity.kind_metadata || {},
        });
      }
      const rows = entity?.mentions || [];
      if (!entity || !rows.length) {
        entityMentionsResultsEl.innerHTML = `<div class="search-result">No entity mentions available.</div>`;
        if (!preserveFocus) renderLeftEntityContext();
        else {
          if (!preserveConnection) clearSelectedConnection({ preserveEvidencePanel: true });
          updateEvidencePanelMode();
        }
        updateExplorationWorkspaceVisibility();
        focusEvidencePanel(mentionsSectionEl);
        syncWorkspaceHeight();
        return;
      }
      const titleLabel = labelHint || entity.display_value;
      const safeTitleLabel = escapeHtml(titleLabel || "");
      const titleLabelHtml = preserveFocus ? `<span class="context-hit">${safeTitleLabel}</span>` : safeTitleLabel;
      entityMentionsResultsEl.innerHTML =
        `<div class="entity-title">Mentions for ${titleLabelHtml}${preserveFocus ? " (focus unchanged)" : ""}</div>` +
        rows.map((m) => (
          `<div class="search-result"><div class="mention-meta"><span>meeting ${m.meeting_id}</span><span>${escapeHtml(m.source_type || "")}</span><span>confidence: ${Number(m.confidence || 0).toFixed(2)}</span></div><div class="mention-context">${highlightEvidenceSnippet(m.context_text || m.mention_text || "", snippetHighlightLabels)}</div></div>`
        )).join("");
      if (!preserveFocus) renderLeftEntityContext();
      else {
        if (!preserveConnection) clearSelectedConnection({ preserveEvidencePanel: true });
        updateEvidencePanelMode();
      }
      updateExplorationWorkspaceVisibility();
      focusEvidencePanel(mentionsSectionEl);
      syncWorkspaceHeight();
    }

    function renderStartupExplore(payload) {
      const entities = payload?.entities || [];
      const topics = payload?.topics || [];
      const canRenderTopics = startupTopicsResultsEl instanceof HTMLElement;
      const canRenderEntities = startupEntitiesResultsEl instanceof HTMLElement;
      if (!canRenderTopics || !canRenderEntities) return;
      if (!entities.length && !topics.length) {
        startupTopicsResultsEl.innerHTML = `<div class="search-result">No saved topics yet. Run ingest to populate the explorer.</div>`;
        startupEntitiesResultsEl.innerHTML = `<div class="search-result">No saved entities yet. Run ingest to populate the explorer.</div>`;
        return;
      }
      startupTopicsResultsEl.innerHTML = topics.length
        ? `<div class="startup-panel"><div class="entity-list">${topics.map((t) => `<button type="button" class="entity-chip ${globalFilters.topic === t.topic ? "active" : ""}" data-topic="${t.topic}">${t.topic} (${t.count})</button>`).join("")}</div></div>`
        : `<div class="search-result">No popular topics yet.</div>`;
      startupEntitiesResultsEl.innerHTML = entities.length
        ? `<div class="startup-panel"><div class="entity-list">${entities.map((e) => {
            const meetingBinding = (e.bindings || []).find((b) => b.source_table === "meetings");
            const attrs = [
              `type="button"`,
              `class="entity-chip ${globalFilters.entityQuery === e.display_value ? "active" : ""}"`,
              `data-entity-id="${e.entity_id}"`,
              `data-entity-type="${e.entity_type || ""}"`,
              `data-entity-seed="${String(e.display_value || "").replace(/"/g, "&quot;")}"`,
            ];
            if (e.normalized_value) attrs.push(`data-entity-normalized="${String(e.normalized_value).replace(/"/g, "&quot;")}"`);
            if (meetingBinding && Number.isFinite(Number(meetingBinding.source_id))) {
              attrs.push(`data-entity-meeting-id="${Number(meetingBinding.source_id)}"`);
            }
            return `<button ${attrs.join(" ")}>${e.display_value}</button>`;
          }).join("")}</div></div>`
        : `<div class="search-result">No popular entities yet.</div>`;
      syncWorkspaceHeight();
    }

    function renderTimelineResults(rows) {
      if (!rows.length) {
        timelineResultsEl.innerHTML = `<div class="search-result">No timeline events found.</div>`;
        syncWorkspaceHeight();
        return;
      }
      timelineResultsEl.innerHTML = `<div class="search-subtitle">Time Facet (date entities)</div>` + rows.map((row) => {
        const entityId = Number(row.entity_id || 0);
        const meetingIds = Array.isArray(row.meeting_ids) ? row.meeting_ids : [];
        const isConnectionSelected = Boolean(
          selectedConnectionContext &&
          Number(selectedConnectionContext.toEntityId || 0) === entityId
        );
        const isFocusedDate = Boolean(
          !selectedConnectionContext &&
          selectedEntityContext &&
          Number(selectedEntityContext.entityId || 0) === entityId
        );
        const rowClasses = ["search-result"];
        if (isConnectionSelected) rowClasses.push("related", "active-edge");
        else if (isFocusedDate) rowClasses.push("active");
        const relationMatch = Array.isArray(lastEntityRelatedRows)
          ? lastEntityRelatedRows.find((r) => Number(r.entity_id) === entityId && Object.prototype.hasOwnProperty.call(r, "relation_type"))
          : null;
        const relationHint = relationMatch
          ? ` â€¢ connected: ${escapeHtml(String(relationMatch.relation_type || ""))} (${escapeHtml(String(relationMatch.direction || ""))})`
          : "";
        return `
          <div class="${rowClasses.join(" ")}">
            <div class="node-result-head">
              <button
                type="button"
                data-timeline-entity-id="${entityId}"
                data-timeline-entity-label="${String(row.label || "").replace(/"/g, "&quot;")}"
                data-timeline-entity-date="${String(row.date || "").replace(/"/g, "&quot;")}"
                data-timeline-meeting-ids="${meetingIds.join(",")}"
              >${escapeHtml(row.label || "")}</button>
              <span class="node-result-kind">date</span>
            </div>
            <div class="meta">normalized date: ${escapeHtml(String(row.date || ""))} â€¢ meetings: ${meetingIds.join(", ")} â€¢ mentions: ${Number(row.entity_count || 0)}${relationHint}</div>
          </div>
        `;
      }).join("");
      syncWorkspaceHeight();
    }

    function renderMapResults(rows) {
      if (!rows.length) {
        mapResultsEl.innerHTML = `<div class="search-result">No address entities found.</div>`;
        syncWorkspaceHeight();
        return;
      }
      mapResultsEl.innerHTML = `<div class="search-subtitle">Place Facet (address entities; external map links)</div>` + rows.map((row) => (
        `<div class="search-result"><button type="button" data-entity-id="${row.entity_id}" data-entity-type="address" data-entity-seed="${String(row.address || "").replace(/"/g, "&quot;")}">${row.address}</button> <span class="meta">(address)</span><div class="meta">city: ${row.city_hint} â€¢ state: ${row.state_hint} â€¢ shared meetings: ${row.shared_meeting_count} â€¢ mentions: ${row.mention_count}</div><a class="map-link" target="_blank" rel="noreferrer" href="https://www.openstreetmap.org/search?query=${encodeURIComponent(row.map_query)}">Open in OpenStreetMap</a></div>`
      )).join("");
      syncWorkspaceHeight();
    }

    function openFacetPanel(sectionEl) {
      setFacetSectionState(sectionEl, { active: true, expand: true, scrollIntoView: true });
    }

    function toggleFacetPanelShortcut(view, sectionEl) {
      if (!(sectionEl instanceof HTMLElement)) return false;
      const sameView = activeSidebarView === view;
      const isOpen = !sectionEl.classList.contains("collapsed");
      if (sameView && isOpen) {
        sectionEl.classList.add("collapsed");
        sectionEl.classList.remove("facet-active");
        setSidebarView("search");
        syncWorkspaceHeight();
        return true;
      }
      setSidebarView(view);
      openFacetPanel(sectionEl);
      return false;
    }

    async function loadTimelineView() {
      timelineResultsEl.innerHTML = `<div class="search-result">Loading timeline...</div>`;
      const q = (entitySearchEl.value || "").trim();
      const url = q ? `/explore/timeline?q=${encodeURIComponent(q)}` : "/explore/timeline";
      const res = await fetch(url);
      if (!res.ok) throw new Error(`Timeline load failed (${res.status})`);
      renderTimelineResults(await res.json());
    }

    async function loadMapView() {
      mapResultsEl.innerHTML = `<div class="search-result">Loading addresses...</div>`;
      const q = (entitySearchEl.value || "").trim();
      const url = q ? `/explore/locations?q=${encodeURIComponent(q)}` : "/explore/locations";
      const res = await fetch(url);
      if (!res.ok) throw new Error(`Map data load failed (${res.status})`);
      renderMapResults(await res.json());
    }

    function renderSuggestions(rows) {
      if (!rows.length) {
        entitySuggestionsEl.hidden = true;
        entitySuggestionsEl.innerHTML = "";
        return;
      }
      entitySuggestionsEl.innerHTML = rows.map((row) => (
        `<button type="button" class="suggestion-item" data-entity-id="${row.entity_id}" data-suggest-text="${row.display_value}">${row.display_value}<div class="suggestion-meta">${row.entity_type} â€¢ score ${Number(row.score).toFixed(2)}</div></button>`
      )).join("");
      entitySuggestionsEl.hidden = false;
    }

    async function loadSuggestions() {
      const q = (entitySearchEl.value || "").trim();
      if (q.length < 2) {
        renderSuggestions([]);
        return;
      }
      try {
        const params = new URLSearchParams({ q, limit: "8" });
        if (globalFilters.entityType) params.set("entity_type", globalFilters.entityType);
        const res = await fetch(`/entities/suggest?${params.toString()}`);
        if (!res.ok) return;
        const rows = await res.json();
        renderSuggestions(rows);
      } catch {
        renderSuggestions([]);
      }
    }

    function renderContentSearchResults(payload, q) {
      const agenda = payload?.agenda_topics || [];
      const docs = payload?.documents || [];
      const esc = (s) => (s || "").replace(/[&<>]/g, (ch) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;" }[ch]));
      const qRe = q ? new RegExp(`(${q.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&")})`, "ig") : null;
      const hl = (s) => {
        const safe = esc(s || "");
        if (!qRe) return safe;
        return safe.replace(qRe, `<span class="context-hit">$1</span>`);
      };

      let html = "";
      html += `<div class="search-subtitle">Matching Agenda Topics</div>`;
      html += agenda.length
        ? agenda.map((a) => `<div class="search-result"><div><strong>Meeting ${a.meeting_id} â€¢ ${a.item_key}</strong></div><div class="meta">${a.section || "agenda"}</div><div class="mention-context">${hl(a.title)}</div></div>`).join("")
        : `<div class="search-result">No agenda topic matches.</div>`;

      html += `<div class="search-subtitle">Matching Documents</div>`;
      html += docs.length
        ? docs.map((d) => `<div class="search-result"><div><strong>Meeting ${d.meeting_id}</strong> <span class="meta">doc ${d.document_id}</span></div><div class="mention-context"><a href="${d.url}" target="_blank" rel="noreferrer">${hl(d.title)}</a></div></div>`).join("")
        : `<div class="search-result">No document matches.</div>`;

      contentSearchResultsEl.innerHTML = html;
      updateExplorationWorkspaceVisibility();
      syncWorkspaceHeight();
    }

    async function loadRuntimeDiagnostics() {
      try {
        const res = await fetch("/explore/coverage");
        if (!res.ok) throw new Error(`graph summary failed (${res.status})`);
        renderGraphDiagnostics(await res.json());
      } catch (err) {
        runtimePanelEl.textContent = err.message || "Graph summary unavailable.";
      }
    }

    async function loadCoverageSummary() {
      try {
        const res = await fetch("/explore/coverage");
        if (!res.ok) throw new Error(`coverage load failed (${res.status})`);
        const payload = await res.json();
        renderCoverageStats(payload);
        renderGraphDiagnostics(payload);
      } catch (err) {
        coverageStatsEl.innerHTML = "";
        recentRangesEl.innerHTML = `<div class="range-row">${err.message || "Unable to load coverage summary."}</div>`;
        renderGraphDiagnostics(null);
      }
    }

    async function loadRangeCacheStatus() {
      try {
        const params = new URLSearchParams({
          from_date: fromDate.value,
          to_date: toDate.value,
          crawl: String(document.getElementById("crawl").checked),
          chunk_days: document.getElementById("chunkDays").value || "31",
          cache_ttl_minutes: document.getElementById("cacheTtlMinutes").value || "60",
        });
        const res = await fetch(`/ingest/cache-status?${params.toString()}`);
        if (!res.ok) throw new Error(`cache status failed (${res.status})`);
        renderRangeCacheStatus(await res.json());
      } catch (err) {
        rangeCacheStatusEl.textContent = err.message || "Cache status unavailable.";
      }
    }

    async function loadStoredMeetingsBrowse() {
      browseStoredMeetingsBtn.disabled = true;
      storedMeetingsListEl.innerHTML = `<div class="browse-row">Loading stored meetings...</div>`;
      setBrowseStatus("Loading stored meetings from local database...");
      try {
        const params = new URLSearchParams({
          limit: "25",
          date_from: fromDate.value || "",
          date_to: toDate.value || "",
        });
        const topic = (topicEl.value || "").trim();
        if (topic) params.set("topic", topic);
        const q = (globalFilters.entityQuery || "").trim();
        if (q) params.set("q", q);
        const res = await fetch(`/stored/meetings?${params.toString()}`);
        if (!res.ok) throw new Error(`stored meetings load failed (${res.status})`);
        renderStoredMeetingsBrowse(await res.json());
        setBrowseStatus("Loaded stored meetings from local database.");
      } catch (err) {
        storedMeetingsListEl.innerHTML = `<div class="browse-row">${err.message || "Unable to load stored meetings."}</div>`;
        setBrowseStatus(err.message || "Unable to load stored meetings.", true);
      } finally {
        browseStoredMeetingsBtn.disabled = false;
      }
    }

    async function loadTopicBrowser() {
      try {
        const q = (topicEl.value || "").trim();
        const url = q ? `/explore/topics?q=${encodeURIComponent(q)}&limit=20` : "/explore/topics?limit=20";
        const res = await fetch(url);
        if (!res.ok) throw new Error(`topic browser load failed (${res.status})`);
        renderTopicBrowser(await res.json());
      } catch (err) {
        topicBrowserListEl.innerHTML = `<div class="browse-row">${err.message || "Unable to load topic browser."}</div>`;
      }
    }

    async function openStoredMeeting(meetingId, meetingMeta = {}, opts = {}) {
      const { focusMeeting = true } = opts;
      runBtn.disabled = true;
      const meetingNum = Number(meetingId);
      selectedContextMeetingId = meetingNum;
      setGlobalMeetingFilter(Number.isFinite(meetingNum) ? meetingNum : null);
      if (focusMeeting) {
        setSelectedMeetingContext({
          meetingId: meetingNum,
          name: meetingMeta.name || "",
          location: meetingMeta.location || "",
          time: meetingMeta.time || "",
          agendaItemCount: meetingMeta.agendaItemCount || 0,
          documentCount: meetingMeta.documentCount || 0,
          entityCount: meetingMeta.entityCount || 0,
          minutesCount: meetingMeta.minutesCount || 0,
        });
      }
      setBrowseStatus(`Loading stored meeting ${meetingId}...`);
      for (const row of storedMeetingsListEl.querySelectorAll(".browse-row")) {
        row.classList.remove("active");
      }
      const activeBtn = storedMeetingsListEl.querySelector(`[data-open-meeting-id="${meetingId}"]`);
      if (activeBtn && activeBtn.closest(".browse-row")) {
        activeBtn.closest(".browse-row").classList.add("active");
      }
      try {
        const topic = (topicEl.value || "").trim();
        const loaded = await loadAgendaForMeetings([meetingNum], topic);
        lastMeetingResults = loaded.meetingResults;
        const loadedMeeting = loaded.meetingResults[0];
        if (loadedMeeting && focusMeeting) {
          setSelectedMeetingContext({
            meetingId: meetingNum,
            name: meetingMeta.name || "",
            location: meetingMeta.location || "",
            time: meetingMeta.time || "",
            agendaItemCount: loadedMeeting.agendaItems?.length || 0,
            documentCount: (() => {
              const seen = new Set();
              for (const item of (loadedMeeting.agendaItems || [])) {
                for (const d of (item.documents || [])) seen.add(`${d.document_id}:${d.url}`);
              }
              return seen.size;
            })(),
            entityCount: (loadedMeeting.entities || []).length || 0,
            minutesCount: (loadedMeeting.minutesMetadata || []).length || 0,
          });
        }
        renderResults(lastMeetingResults, topic);
        document.getElementById("kItems").textContent = String(loaded.totalItems);
        summaryEl.hidden = false;
        if (mainColEl instanceof HTMLElement) mainColEl.scrollTop = 0;
        void loadStoredMeetingsBrowse();
        setBrowseStatus(`Loaded stored meeting ${meetingId}.`);
      } catch (err) {
        setBrowseStatus(err.message || "Unable to load stored meeting.", true);
      } finally {
        runBtn.disabled = false;
      }
    }

    async function loadStartupExplore() {
      try {
        const res = await fetch("/explore/popular");
        if (!res.ok) throw new Error(`Explore load failed (${res.status})`);
        renderStartupExplore(await res.json());
      } catch (err) {
        const msg = err.message || "Unable to load explorer seed data.";
        if (startupTopicsResultsEl instanceof HTMLElement) startupTopicsResultsEl.innerHTML = `<div class="search-result">${msg}</div>`;
        if (startupEntitiesResultsEl instanceof HTMLElement) startupEntitiesResultsEl.innerHTML = `<div class="search-result">${msg}</div>`;
      }
    }

    async function loadEntityConnections(entityId, entityLabel, entityType = "", bindings = [], kindMetadata = {}) {
      try {
        const res = await fetch(`/entities/${entityId}/connections?limit=25`);
        if (!res.ok) throw new Error(`Connections lookup failed (${res.status})`);
        const rows = await res.json();
        const incomingFocusKey = `${(entityType || "entity").toLowerCase()}:${Number(entityId)}`;
        const currentFocusKey = lastConnectionFocus ? `${(lastConnectionFocus.entityType || "entity").toLowerCase()}:${Number(lastConnectionFocus.entityId)}` : "";
        if (incomingFocusKey !== currentFocusKey) {
          clearSelectedConnection({ preserveEvidencePanel: true });
        }
        lastConnectionFocus = {
          entityId: Number(entityId),
          label: entityLabel,
          entityType: (entityType || "").trim(),
          bindings: Array.isArray(bindings) ? bindings : [],
          kindMetadata: (kindMetadata && typeof kindMetadata === "object") ? kindMetadata : {},
        };
        if (entityType !== "meeting") {
          setSelectedEntityContext({ entityId, label: entityLabel, entityType, bindings, kindMetadata });
        }
        renderEntityRelatedResults(rows, entityLabel);
        const preserveTrailSync = activeMainView === "graph" && graphWalkPreserveTrailOnNextFocusSync;
        void syncGraphWalkFromCurrentFocus({ forceReset: !preserveTrailSync });
      } catch (err) {
        entityRelatedResultsEl.innerHTML = `<div class="search-result">${err.message || "Connections lookup failed."}</div>`;
        lastEntityRelatedRows = [];
        graphWalkPreserveTrailOnNextFocusSync = false;
        renderLeftEntityContext();
        renderGraphWalk();
      }
    }

    async function loadMeetingFocusConnections(meetingId) {
      const meetingNum = Number(meetingId || 0);
      if (!Number.isFinite(meetingNum) || meetingNum <= 0) return;
      try {
        const res = await fetch(`/entities/search?q=${encodeURIComponent(`meeting ${meetingNum}`)}&entity_type=meeting&limit=10`);
        if (!res.ok) throw new Error(`Meeting graph lookup failed (${res.status})`);
        const rows = await res.json();
        const match =
          (rows || []).find((r) => Array.isArray(r.bindings) && r.bindings.some((b) => b.source_table === "meetings" && Number(b.source_id) === meetingNum)) ||
          (rows || []).find((r) => String(r.normalized_value || "") === `meeting:${meetingNum}`) ||
          null;
        if (!match) {
          lastConnectionFocus = null;
          lastEntityRelatedRows = [];
          graphWalkPreserveTrailOnNextFocusSync = false;
          entityRelatedResultsEl.innerHTML = `<div class="search-result">No graph connections found for Meeting ${meetingNum}. Run graph backfill if this meeting predates graph entities.</div>`;
          renderLeftEntityContext();
          renderGraphWalk();
          updateExplorationWorkspaceVisibility();
          syncWorkspaceHeight();
          return;
        }
        await loadEntityConnections(match.entity_id, match.display_value || `Meeting ${meetingNum}`, "meeting", match.bindings || [], match.kind_metadata || {});
      } catch (err) {
        lastConnectionFocus = null;
        lastEntityRelatedRows = [];
        graphWalkPreserveTrailOnNextFocusSync = false;
        entityRelatedResultsEl.innerHTML = `<div class="search-result">${err.message || "Meeting graph lookup failed."}</div>`;
        renderLeftEntityContext();
        renderGraphWalk();
        updateExplorationWorkspaceVisibility();
        syncWorkspaceHeight();
      }
    }

    async function loadConnectionEvidence(otherEntityId, relationType, direction) {
      if (!lastConnectionFocus || !lastConnectionFocus.entityId) {
        entityMentionsResultsEl.innerHTML = `<div class="search-result">Select a focused entity before loading connection evidence.</div>`;
        updateExplorationWorkspaceVisibility();
        syncWorkspaceHeight();
        return;
      }
      try {
        const params = new URLSearchParams({
          relation_type: relationType,
          direction,
          limit: "100",
        });
        const res = await fetch(`/entities/${lastConnectionFocus.entityId}/connections/${otherEntityId}/evidence?${params.toString()}`);
        if (!res.ok) throw new Error(`Connection evidence failed (${res.status})`);
        const rows = await res.json();
        const relatedRow = (lastEntityRelatedRows || []).find((r) => Number(r.entity_id) === Number(otherEntityId) && String(r.relation_type || "") === String(relationType || "") && String(r.direction || "") === String(direction || ""));
        const relatedLabel = relatedRow?.display_value || `entity ${otherEntityId}`;
        selectedConnectionContext = {
          fromEntityId: Number(lastConnectionFocus.entityId),
          fromLabel: lastConnectionFocus.label,
          toEntityId: Number(otherEntityId),
          toLabel: relatedLabel,
          relationType,
          direction,
          edgeCount: Number(relatedRow?.edge_count || 0),
          evidenceCount: Number(relatedRow?.evidence_count || 0),
          sharedMeetingCount: Number(relatedRow?.shared_meeting_count || 0),
          rows,
        };
        renderEntityRelatedResults(lastEntityRelatedRows || [], lastConnectionFocus.label);
        renderLeftEntityContext();
        renderGraphWalk();
        const title = `Evidence: ${lastConnectionFocus.label} ${direction === "outgoing" ? "â†’" : "â†"} ${relatedLabel} (${relationType})`;
        if (!rows.length) {
          entityMentionsResultsEl.innerHTML = `<div class="search-result"><div class="entity-title">${title}</div><div class="meta">No evidence rows found for this connection.</div></div>`;
        } else {
          const snippetHighlightLabels = [selectedConnectionContext?.toLabel || relatedLabel];
          entityMentionsResultsEl.innerHTML = `
            <div class="entity-title">${title}</div>
            ${rows.map((row) => `
              <div class="search-result">
                <div class="mention-meta">
                  <span>${escapeHtml(row.relation_type || "")}</span>
                  <span>strength: ${Number(row.strength || 0).toFixed(2)}</span>
                  <span>meeting ${row.meeting_id ?? "?"}</span>
                  <span>${escapeHtml(row.evidence_source_type || "")}:${row.evidence_source_id}</span>
                  ${row.document_id ? `<span>doc ${row.document_id}</span>` : ""}
                </div>
                ${row.mention_text ? `<div class="meta">mention: ${highlightEvidenceSnippet(row.mention_text, snippetHighlightLabels)}</div>` : ""}
                <div class="mention-context">${highlightEvidenceSnippet(row.context_text || "(no context)", snippetHighlightLabels)}</div>
              </div>
            `).join("")}
          `;
        }
        updateExplorationWorkspaceVisibility();
        focusEvidencePanel(mentionsSectionEl);
        syncWorkspaceHeight();
      } catch (err) {
        selectedConnectionContext = null;
        renderEntityRelatedResults(lastEntityRelatedRows || [], lastConnectionFocus?.label || "focus");
        renderLeftEntityContext();
        renderGraphWalk();
        entityMentionsResultsEl.innerHTML = `<div class="search-result">${err.message || "Unable to load connection evidence."}</div>`;
        updateExplorationWorkspaceVisibility();
        focusEvidencePanel(mentionsSectionEl);
        syncWorkspaceHeight();
      }
    }

    function parseMeetingIdFromEntityButton(button) {
      if (!(button instanceof HTMLElement)) return null;
      const explicit = Number(button.dataset.entityMeetingId || 0);
      if (Number.isFinite(explicit) && explicit > 0) return explicit;
      const normalized = String(button.dataset.entityNormalized || "");
      const m = normalized.match(/^meeting:(\d+)$/);
      if (m) return Number(m[1]);
      return null;
    }

    async function loadEntityMentions(entityId, options = {}) {
      try {
        const res = await fetch(`/entities/${entityId}?mention_limit=200`);
        if (!res.ok) throw new Error(`Entity detail failed (${res.status})`);
        const entity = await res.json();
        renderEntityMentionsDetail(entity, options);
      } catch (err) {
        entityMentionsResultsEl.innerHTML = `<div class="search-result">${err.message || "Unable to load mentions."}</div>`;
      }
    }

    function syncWorkspaceHeight() {
      const workspace = document.querySelector(".workspace");
      const graphWalkPanel = graphWalkViewPanelEl instanceof HTMLElement ? graphWalkViewPanelEl : null;
      if (!(workspace instanceof HTMLElement) && !graphWalkPanel) return;
      if (window.innerWidth <= 900) {
        if (workspace instanceof HTMLElement) workspace.style.height = "auto";
        if (graphWalkPanel) graphWalkPanel.style.height = "auto";
        return;
      }
      const topAnchor = (activeMainView === "graph" && graphWalkPanel) ? graphWalkPanel : workspace;
      if (!(topAnchor instanceof HTMLElement)) return;
      const top = topAnchor.getBoundingClientRect().top;
      const height = Math.max(360, Math.floor(window.innerHeight - top - 12));
      if (workspace instanceof HTMLElement) workspace.style.height = `${height}px`;
      if (graphWalkPanel) graphWalkPanel.style.height = `${height}px`;
    }

    async function searchEntities(options = {}) {
      const { focusFirstMeeting = false } = options;
      const q = (entitySearchEl.value || "").trim();
      const entityType = (globalFilters.entityType || "").trim();
      setSidebarView("search");
      if (!q) {
        entitySearchResultsEl.innerHTML = "";
        meetingSearchResultsEl.innerHTML = "";
        contentSearchResultsEl.innerHTML = "";
        entityRelatedResultsEl.innerHTML = "";
        entityMentionsResultsEl.innerHTML = "";
        lastEntitySearchRows = [];
        renderTopSearchPreview([]);
        lastEntityRelatedRows = [];
        setGlobalEntityFilter("");
        void loadStoredMeetingsBrowse();
        setBrowseStatus("Cleared entity search filter.");
        renderSuggestions([]);
        updateExplorationWorkspaceVisibility();
        renderLeftEntityContext();
        return;
      }
      renderSuggestions([]);
      setGlobalEntityFilter(q);
      setBrowseStatus(`Searching nodes${entityType ? ` (${entityType})` : ""} for "${q}"...`);
      entitySearchBtn.disabled = true;
      try {
        const entityParams = new URLSearchParams({ q });
        if (entityType) entityParams.set("entity_type", entityType);
        const fetchMeetingConvenience = !entityType || entityType === "meeting";
        const [entityRes, meetingRes, contentRes] = await Promise.all([
          fetch(`/entities/search?${entityParams.toString()}`),
          fetchMeetingConvenience
            ? fetch(`/stored/meetings?q=${encodeURIComponent(q)}&limit=10`)
            : Promise.resolve(new Response("[]", { status: 200, headers: { "Content-Type": "application/json" } })),
          fetch(`/search/content?q=${encodeURIComponent(q)}`),
        ]);
        if (!entityRes.ok) throw new Error(`Entity search failed (${entityRes.status})`);
        if (!meetingRes.ok) throw new Error(`Meeting search failed (${meetingRes.status})`);
        if (!contentRes.ok) throw new Error(`Content search failed (${contentRes.status})`);
        const rows = await entityRes.json();
        const meetingRows = await meetingRes.json();
        const content = await contentRes.json();
        renderEntitySearchResults(rows);
        renderMeetingSearchResults(meetingRows);
        renderContentSearchResults(content, q);
        if (focusFirstMeeting && meetingRows.length) {
          const first = meetingRows[0];
          await openStoredMeeting(first.meeting_id, {
            name: first.name,
            location: first.location,
            time: first.time,
            agendaItemCount: first.agenda_item_count,
            documentCount: first.document_count,
            entityCount: first.entity_count,
            minutesCount: first.minutes_count,
          }, { focusMeeting: false });
        } else {
          void loadStoredMeetingsBrowse();
        }
        setBrowseStatus(`Node search complete for "${q}"${entityType ? ` â€¢ kind: ${entityType}` : ""}.`);
      } catch (err) {
        entitySearchResultsEl.innerHTML = `<div class="search-result">${err.message || "Search failed."}</div>`;
        meetingSearchResultsEl.innerHTML = "";
        contentSearchResultsEl.innerHTML = "";
        lastEntitySearchRows = [];
        renderTopSearchPreview([]);
        lastEntityRelatedRows = [];
        renderLeftEntityContext();
        updateExplorationWorkspaceVisibility();
        setBrowseStatus(err.message || "Search failed.", true);
      } finally {
        entitySearchBtn.disabled = false;
      }
    }

    async function runQuery(event) {
      event.preventDefault();
      runBtn.disabled = true;
      selectedContextMeetingId = null;
      resultsEl.innerHTML = "";
      summaryEl.hidden = true;
      relatedEl.hidden = true;
      progressWrap.hidden = false;
      setProgress(0, 0);

      const params = new URLSearchParams({
        from_date: fromDate.value,
        to_date: toDate.value,
        limit: document.getElementById("limit").value,
        crawl: String(document.getElementById("crawl").checked),
        chunk_days: document.getElementById("chunkDays").value,
        store_raw: String(document.getElementById("storeRaw").checked),
        use_recent_cache: String(document.getElementById("useRecentCache").checked),
        cache_ttl_minutes: document.getElementById("cacheTtlMinutes").value,
      });

      const topic = topicEl.value;

      try {
        setIngestStatus("Starting ingest job...");
        const job = await startIngestJob(params);
        const ingest = await pollJob(job.job_id);

        const meetingIds = (ingest.results || []).map((r) => r.meeting_id).filter(Boolean);
        const loaded = await loadAgendaForMeetings(meetingIds, topic);

        document.getElementById("kDiscovered").textContent = String(ingest.discovered || 0);
        document.getElementById("kIngested").textContent = String(ingest.ingested || 0);
        document.getElementById("kItems").textContent = String(loaded.totalItems);
        summaryEl.hidden = false;

        lastMeetingResults = loaded.meetingResults;
        lastIngestSummary = ingest;

        setGlobalTopicFilter(topic || "");
        renderResults(lastMeetingResults, topic);
        await loadRangeCacheStatus();
        await loadCoverageSummary();
        await loadStoredMeetingsBrowse();
        await loadTopicBrowser();
        setIngestStatus("Completed.");
      } catch (error) {
        setIngestStatus(error.message || "Something went wrong.", true);
      } finally {
        runBtn.disabled = false;
      }
    }

    async function rerunTopicOnly(topic) {
      if (!lastIngestSummary) return;
      runBtn.disabled = true;
      try {
        selectedContextMeetingId = null;
        const meetingIds = (lastIngestSummary.results || []).map((r) => r.meeting_id).filter(Boolean);
        const loaded = await loadAgendaForMeetings(meetingIds, topic);
        lastMeetingResults = loaded.meetingResults;
        document.getElementById("kItems").textContent = String(loaded.totalItems);
        renderResults(lastMeetingResults, topic);
        setGlobalTopicFilter(topic || "");
        void loadStoredMeetingsBrowse();
        void loadTopicBrowser();
        setBrowseStatus(`Filtered by topic: ${topic || "all"}.`);
      } finally {
        runBtn.disabled = false;
      }
    }

    form.addEventListener("submit", runQuery);
    entitySearchBtn.addEventListener("click", searchEntities);
    if (entityTypeFilterRowEl instanceof HTMLElement) {
      entityTypeFilterRowEl.addEventListener("click", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) return;
        const btn = target.closest("[data-entity-type-filter]");
        if (!(btn instanceof HTMLElement)) return;
        const nextType = btn.dataset.entityTypeFilter || "";
        const changed = String(globalFilters.entityType || "") !== String(nextType || "");
        setGlobalEntityTypeFilter(nextType);
        if (!changed) return;
        if ((entitySearchEl.value || "").trim()) {
          void searchEntities();
        } else {
          entitySearchResultsEl.innerHTML = "";
          meetingSearchResultsEl.innerHTML = "";
          updateExplorationWorkspaceVisibility();
          syncWorkspaceHeight();
        }
      });
    }
    if (clearSelectedConnectionBtn instanceof HTMLElement) {
      clearSelectedConnectionBtn.addEventListener("click", (event) => {
        event.preventDefault();
        clearSelectedConnection({ preserveEvidencePanel: false });
        if (lastConnectionFocus && Array.isArray(lastEntityRelatedRows) && lastEntityRelatedRows.length) {
          renderEntityRelatedResults(lastEntityRelatedRows, lastConnectionFocus.label);
        }
      });
    }
    if (backToFocusNodeBtn instanceof HTMLElement) {
      backToFocusNodeBtn.addEventListener("click", (event) => {
        event.preventDefault();
        clearSelectedConnection({ preserveEvidencePanel: true });
        if (lastConnectionFocus && Array.isArray(lastEntityRelatedRows) && lastEntityRelatedRows.length) {
          renderEntityRelatedResults(lastEntityRelatedRows, lastConnectionFocus.label);
        }
        if (selectedEntityContext && selectedEntityContext.entityId) {
          void loadEntityMentions(selectedEntityContext.entityId);
          return;
        }
        renderLeftEntityContext();
        updateExplorationWorkspaceVisibility();
      });
    }
    if (clearCurrentFocusBtn instanceof HTMLElement) {
      clearCurrentFocusBtn.addEventListener("click", (event) => {
        event.preventDefault();
        clearCurrentFocusState({ clearFocusFilters: true });
      });
    }
    clearAllFiltersBtn.addEventListener("click", async () => {
      setGlobalTopicFilter("");
      setGlobalEntityFilter("");
      setGlobalEntityTypeFilter("");
      setGlobalMeetingFilter(null);
      lastEntitySearchRows = [];
      renderTopSearchPreview([]);
      topicEl.value = "";
      entitySearchEl.value = "";
      renderSuggestions([]);
      entitySearchResultsEl.innerHTML = "";
      meetingSearchResultsEl.innerHTML = "";
      contentSearchResultsEl.innerHTML = "";
      if (lastIngestSummary) {
        await rerunTopicOnly("");
      } else {
        void loadStoredMeetingsBrowse();
        void loadTopicBrowser();
      }
      renderLeftEntityContext();
      updateExplorationWorkspaceVisibility();
    });
    tabSearchEl.addEventListener("click", () => {
      setSidebarView("search");
      const scroller = document.querySelector(".sidebar-scroll");
      if (scroller instanceof HTMLElement) {
        scroller.scrollTo({ top: 0, behavior: "smooth" });
      }
    });
    tabTimelineEl.addEventListener("click", async () => {
      const closed = toggleFacetPanelShortcut("timeline", timelineSectionEl);
      if (closed) return;
      try { await loadTimelineView(); } catch (err) { timelineResultsEl.innerHTML = `<div class="search-result">${err.message || "Timeline load failed."}</div>`; }
    });
    tabMapEl.addEventListener("click", async () => {
      const closed = toggleFacetPanelShortcut("map", mapSectionEl);
      if (closed) return;
      try { await loadMapView(); } catch (err) { mapResultsEl.innerHTML = `<div class="search-result">${err.message || "Map load failed."}</div>`; }
    });
    if (meetingDetailToggleEl instanceof HTMLElement) {
      meetingDetailToggleEl.addEventListener("click", () => {
        setMeetingDetailCollapsed(!meetingDetailCollapsed);
      });
      setMeetingDetailCollapsed(false);
    }
    if (pinnedFocusSnapshotToggleEl instanceof HTMLElement) {
      pinnedFocusSnapshotToggleEl.addEventListener("click", () => {
        setPinnedFocusSnapshotCollapsed(!pinnedFocusSnapshotCollapsed);
      });
      setPinnedFocusSnapshotCollapsed(false);
    }
    if (topExplorerCompactToggleEl instanceof HTMLElement) {
      topExplorerCompactToggleEl.addEventListener("click", () => {
        setTopExplorerCompact(!topExplorerCompact);
      });
      setTopExplorerCompact(false);
    }
    if (workbenchViewBtnEl instanceof HTMLElement) {
      workbenchViewBtnEl.addEventListener("click", () => setMainViewMode("workbench"));
    }
    if (graphWalkViewBtnEl instanceof HTMLElement) {
      graphWalkViewBtnEl.addEventListener("click", () => setMainViewMode("graph"));
    }
    if (graphWalkSyncToFocusBtnEl instanceof HTMLElement) {
      graphWalkSyncToFocusBtnEl.addEventListener("click", () => {
        graphWalkResetZoom();
        void syncGraphWalkFromCurrentFocus({ forceReset: true });
      });
    }
    if (graphWalkZoomOutBtnEl instanceof HTMLElement) {
      graphWalkZoomOutBtnEl.addEventListener("click", () => graphWalkZoomBy(0.82));
    }
    if (graphWalkZoomResetBtnEl instanceof HTMLElement) {
      graphWalkZoomResetBtnEl.addEventListener("click", () => graphWalkResetZoom());
    }
    if (graphWalkZoomInBtnEl instanceof HTMLElement) {
      graphWalkZoomInBtnEl.addEventListener("click", () => graphWalkZoomBy(1.22));
    }
    if (graphWalkClearTrailBtnEl instanceof HTMLElement) {
      graphWalkClearTrailBtnEl.addEventListener("click", () => {
        if (graphWalkFocusEntity) {
          graphWalkTrail = [Number(graphWalkFocusEntity.entityId)];
          renderGraphWalk();
        } else {
          clearGraphWalkState();
        }
      });
    }
    loadRuntimeDiagnostics();
    loadStartupExplore();
    loadCoverageSummary();
    loadRangeCacheStatus();
    loadStoredMeetingsBrowse();
    loadTopicBrowser();
    renderGlobalFilterChips();
    updateEntityTypeFilterButtons();
    updateResultsContextHeader();
    renderLeftEntityContext();
    mountFilterBarIntoTopPanel();
    mountExplorerControlsTop();
    mountEntitySearchIntoTopPanel();
    mountExistingDataPanelInLeftPane();
    mountExplorationSectionsInLeftPane();
    positionExplorationFlowPanels();
    updateExplorationWorkspaceVisibility();
    updateDiscoveryStartsVisibility();
    setSidebarView("search");
    mountOperationsPanelInSidebar();
    setMainViewMode("workbench");
    syncWorkspaceHeight();
    window.addEventListener("load", syncWorkspaceHeight);
    if (document.fonts && document.fonts.ready) {
      document.fonts.ready.then(() => syncWorkspaceHeight()).catch(() => {});
    }
    if (typeof ResizeObserver !== "undefined") {
      const layoutResizeObserver = new ResizeObserver(() => syncWorkspaceHeight());
      const heroEl = document.querySelector(".hero");
      const filterBarEl = document.querySelector(".filter-bar");
      if (heroEl instanceof HTMLElement) layoutResizeObserver.observe(heroEl);
      if (filterBarEl instanceof HTMLElement) layoutResizeObserver.observe(filterBarEl);
    }
    window.addEventListener("resize", syncWorkspaceHeight);
    entitySearchEl.addEventListener("input", () => {
      if (suggestTimer) clearTimeout(suggestTimer);
      suggestTimer = setTimeout(loadSuggestions, 180);
    });
    browseStoredMeetingsBtn.addEventListener("click", loadStoredMeetingsBrowse);
    refreshTopicBrowserBtn.addEventListener("click", loadTopicBrowser);
    entitySearchEl.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        searchEntities();
      }
    });
    for (const el of [fromDate, toDate, document.getElementById("crawl"), document.getElementById("chunkDays"), document.getElementById("cacheTtlMinutes")]) {
      el.addEventListener("input", () => {
        if (coverageTimer) clearTimeout(coverageTimer);
        coverageTimer = setTimeout(loadRangeCacheStatus, 180);
      });
      el.addEventListener("change", () => {
        if (coverageTimer) clearTimeout(coverageTimer);
        coverageTimer = setTimeout(loadRangeCacheStatus, 100);
      });
    }

    document.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      const titleEl = target.closest(".sidebar-section-title");
      if (!(titleEl instanceof HTMLElement)) return;
      const sectionEl = titleEl.closest(".sidebar-section");
      if (!(sectionEl instanceof HTMLElement)) return;
      if (sectionEl.classList.contains("evidence-flat")) return;
      sectionEl.classList.toggle("collapsed");
      syncWorkspaceHeight();
    });

    document.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      const graphNode = target.closest("[data-graph-node-id]");
      if (graphNode instanceof HTMLElement) {
        event.preventDefault();
        const entityId = Number(graphNode.dataset.graphNodeId || 0);
        if (Number.isFinite(entityId) && entityId > 0) {
          void (async () => {
            const selectedAsConnection = await graphWalkSelectConnectionForNode(entityId);
            if (!selectedAsConnection) {
              await graphWalkFocusNodeById(entityId);
            }
          })();
        }
        return;
      }
      const crumb = target.closest("[data-graph-crumb-id]");
      if (crumb instanceof HTMLElement) {
        event.preventDefault();
        const entityId = Number(crumb.dataset.graphCrumbId || 0);
        if (Number.isFinite(entityId) && entityId > 0) {
          void graphWalkFocusNodeById(entityId);
        }
        return;
      }
      const walkBtn = target.closest("[data-graph-walk-node-id]");
      if (walkBtn instanceof HTMLElement) {
        event.preventDefault();
        const entityId = Number(walkBtn.dataset.graphWalkNodeId || 0);
        if (Number.isFinite(entityId) && entityId > 0) {
          void graphWalkFocusNodeById(entityId);
        }
        return;
      }
    });

    document.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      const lensBtn = target.closest("[data-quick-topic], [data-quick-query]");
      if (!(lensBtn instanceof HTMLElement)) return;
      const quickTopic = lensBtn.dataset.quickTopic || "";
      const quickQuery = lensBtn.dataset.quickQuery || "";
      if (quickTopic) {
        setGlobalTopicFilter(quickTopic);
        void loadTopicBrowser();
        void loadStoredMeetingsBrowse();
        if (lastIngestSummary) void rerunTopicOnly(quickTopic);
      }
      if (quickQuery) {
        entitySearchEl.value = quickQuery;
        setGlobalEntityFilter(quickQuery);
        void searchEntities({ focusFirstMeeting: true });
      }
    });

    document.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      if (!target.classList.contains("chip")) return;
      if (!target.dataset.topic) return;

      const topic = target.dataset.topic || "";
      setGlobalTopicFilter(topic);
      updateResultsContextHeader();
      rerunTopicOnly(topic);
    });

    document.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      const jumpBtn = target.closest("[data-flow-jump-target]");
      if (!(jumpBtn instanceof HTMLElement)) return;
      const jumpTarget = String(jumpBtn.dataset.flowJumpTarget || "");
      const targetMap = {
        connect: relatedEntitiesWorkspacePanelEl,
        evidence: explorationWorkspacePanelEl,
        pivot: pivotResultsWorkspacePanelEl,
      };
      const panel = targetMap[jumpTarget];
      if (!(panel instanceof HTMLElement) || !(mainColEl instanceof HTMLElement)) return;
      const top = Math.max(0, panel.offsetTop - 8);
      mainColEl.scrollTo({ top, behavior: "smooth" });
    });

    document.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      const suggestion = target.closest(".suggestion-item");
      if (suggestion instanceof HTMLElement) {
        event.preventDefault();
        event.stopPropagation();
        const text = suggestion.dataset.suggestText || suggestion.textContent || "";
        entitySearchEl.value = text.trim();
        renderSuggestions([]);
        searchEntities({ focusFirstMeeting: true });
        return;
      }
    });

    document.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      if (!target.classList.contains("entity-chip")) return;
      if (target.dataset.entityId) return;
      const query = target.dataset.entityQuery || "";
      setGlobalEntityFilter(query);
      void searchEntities({ focusFirstMeeting: true });
    });

    document.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      const button = target.closest("[data-timeline-entity-id]");
      if (!(button instanceof HTMLElement)) return;
      event.preventDefault();
      event.stopPropagation();

      const entityId = Number(button.dataset.timelineEntityId || 0);
      const label = (button.dataset.timelineEntityLabel || button.textContent || "").trim();
      const dateNormalized = (button.dataset.timelineEntityDate || "").trim();
      if (!Number.isFinite(entityId) || entityId <= 0) return;

      const relationMatches = Array.isArray(lastEntityRelatedRows)
        ? lastEntityRelatedRows
            .filter((r) => Number(r.entity_id) === entityId && Object.prototype.hasOwnProperty.call(r, "relation_type"))
            .sort((a, b) => {
              const ev = Number(b.evidence_count || 0) - Number(a.evidence_count || 0);
              if (ev) return ev;
              return Number(b.edge_count || 0) - Number(a.edge_count || 0);
            })
        : [];

      if (lastConnectionFocus && lastConnectionFocus.entityId && relationMatches.length) {
        const best = relationMatches[0];
        setSidebarView("timeline");
        void loadConnectionEvidence(entityId, String(best.relation_type || ""), String(best.direction || ""));
        return;
      }

      const nextQuery = (label || dateNormalized).trim();
      if (nextQuery) {
        entitySearchEl.value = nextQuery;
        setGlobalEntityFilter(nextQuery);
      }
      setSidebarView("search");
      void (async () => {
        await searchEntities({ focusFirstMeeting: true });
        await loadEntityConnections(
          entityId,
          label || dateNormalized || `date ${entityId}`,
          "date",
          [],
          { normalized_date: dateNormalized || "" },
        );
      })();
    });

    document.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      const button = target.closest("button[data-entity-id]");
      if (!(button instanceof HTMLElement)) return;
      if (button.classList.contains("suggestion-item")) return;
      const entityId = button.dataset.entityId;
      const label = button.textContent || "entity";
      const entityType = (button.dataset.entityType || "").trim().toLowerCase();
      if (!entityId) return;
      const entityIdNum = Number(entityId);
      const matchedRow =
        (lastEntitySearchRows || []).find((r) => Number(r.entity_id) === entityIdNum) ||
        (lastEntityRelatedRows || []).find((r) => Number(r.entity_id) === entityIdNum) ||
        null;
      const bindings = Array.isArray(matchedRow?.bindings) ? matchedRow.bindings : [];
      const kindMetadata =
        (matchedRow?.kind_metadata && typeof matchedRow.kind_metadata === "object")
          ? matchedRow.kind_metadata
          : {};
      const nextQuery = (button.dataset.entitySeed || label || "").trim();
      if (nextQuery) {
        entitySearchEl.value = nextQuery;
        setGlobalEntityFilter(nextQuery);
      }
      if (entityType && entityType !== "meeting") {
        setSelectedEntityContext({
          entityId: entityIdNum,
          label: label.trim(),
          entityType,
          bindings,
          kindMetadata,
        });
      }
      setSidebarView("search");
      void (async () => {
        const meetingEntityId = parseMeetingIdFromEntityButton(button);
        await searchEntities({ focusFirstMeeting: entityType !== "meeting" });
        if (entityType === "meeting" && meetingEntityId) {
          await openStoredMeeting(meetingEntityId, {}, { focusMeeting: true });
        }
        await loadEntityConnections(entityId, label, entityType, bindings, kindMetadata);
      })();
    });

    document.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      const link = target.closest("[data-connection-evidence-entity-id]");
      if (!(link instanceof HTMLElement)) return;
      event.preventDefault();
      const otherEntityId = Number(link.dataset.connectionEvidenceEntityId || 0);
      const relationType = link.dataset.connectionRelationType || "";
      const direction = link.dataset.connectionDirection || "";
      if (!Number.isFinite(otherEntityId) || otherEntityId <= 0 || !relationType || !direction) return;
      setSidebarView("search");
      void loadConnectionEvidence(otherEntityId, relationType, direction);
    });

    document.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      const link = target.closest("[data-entity-mentions-id]");
      if (!(link instanceof HTMLElement)) return;
      event.preventDefault();
      const entityId = link.dataset.entityMentionsId;
      if (!entityId) return;
      const preserveFocus = link.dataset.entityMentionsPreserveFocus === "1";
      const labelHint = link.dataset.entityMentionsLabel || "";
      setSidebarView("search");
      loadEntityMentions(entityId, {
        preserveFocus,
        preserveConnection: preserveFocus,
        labelHint,
      });
    });

    document.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      if (target.closest(".search-box")) return;
      if (!entitySuggestionsEl.hidden) renderSuggestions([]);
    });

    document.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      const button = target.closest("[data-select-context-meeting-id]");
      if (!(button instanceof HTMLElement)) return;
      const meetingId = Number(button.dataset.selectContextMeetingId || 0);
      if (!Number.isFinite(meetingId) || !meetingId) return;
      selectedContextMeetingId = meetingId;
      setGlobalMeetingFilter(meetingId);
      const row = (lastMeetingResults || []).find((r) => Number(r.meetingId) === meetingId);
      if (row) {
        const seenDocs = new Set();
        for (const item of (row.agendaItems || [])) {
          for (const d of (item.documents || [])) seenDocs.add(`${d.document_id}:${d.url}`);
        }
        setSelectedMeetingContext({
          meetingId,
          agendaItemCount: (row.agendaItems || []).length,
          documentCount: seenDocs.size,
          entityCount: (row.entities || []).length,
          minutesCount: (row.minutesMetadata || []).length,
        });
      }
      renderResults(lastMeetingResults || [], topicEl.value || "");
    });

    document.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      const button = target.closest("[data-open-meeting-id]");
      if (!(button instanceof HTMLElement)) return;
      openStoredMeeting(button.dataset.openMeetingId, {
        name: button.dataset.meetingName || "",
        location: button.dataset.meetingLocation || "",
        time: button.dataset.meetingTime || "",
        agendaItemCount: Number(button.dataset.meetingAgendaCount || 0),
        documentCount: Number(button.dataset.meetingDocumentCount || 0),
        entityCount: Number(button.dataset.meetingEntityCount || 0),
        minutesCount: Number(button.dataset.meetingMinutesCount || 0),
      });
    });

    document.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      const button = target.closest("[data-topic-browser]");
      if (!(button instanceof HTMLElement)) return;
      const topic = button.dataset.topicBrowser || "";
      setGlobalTopicFilter(topic);
      rerunTopicOnly(topic);
      void loadStoredMeetingsBrowse();
    });

    document.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      const button = target.closest("[data-apply-range]");
      if (!(button instanceof HTMLElement)) return;
      fromDate.value = button.dataset.rangeFrom || fromDate.value;
      toDate.value = button.dataset.rangeTo || toDate.value;
      document.getElementById("chunkDays").value = button.dataset.rangeChunk || document.getElementById("chunkDays").value;
      document.getElementById("crawl").checked = (button.dataset.rangeCrawl || "true") === "true";
      loadRangeCacheStatus();
    });

    document.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      const snapshotPreviewToggle = target.closest("[data-snapshot-preview-toggle]");
      if (snapshotPreviewToggle instanceof HTMLElement) {
        event.preventDefault();
        setFocusSnapshotMeetingPreviewCollapsed(!focusSnapshotMeetingPreviewCollapsed);
        return;
      }
      const snapshotMeetingToggle = target.closest("[data-snapshot-meeting-toggle]");
      if (snapshotMeetingToggle instanceof HTMLElement) {
        event.preventDefault();
        setMeetingDetailCollapsed(!meetingDetailCollapsed);
        renderPinnedFocusSnapshot();
        return;
      }
      const snapshotJumpDetail = target.closest("[data-snapshot-jump-detail]");
      if (snapshotJumpDetail instanceof HTMLElement) {
        event.preventDefault();
        if (meetingDetailPanelEl instanceof HTMLElement && mainColEl instanceof HTMLElement) {
          const top = Math.max(0, meetingDetailPanelEl.offsetTop - 8);
          mainColEl.scrollTo({ top, behavior: "smooth" });
        }
        return;
      }
      const removeBtn = target.closest("[data-remove-filter]");
      if (!(removeBtn instanceof HTMLElement)) return;
      const key = removeBtn.dataset.removeFilter;
      if (key === "topic") {
        setGlobalTopicFilter("");
        updateResultsContextHeader();
        if (lastIngestSummary) {
          void rerunTopicOnly("");
        } else {
          void loadStoredMeetingsBrowse();
          void loadTopicBrowser();
        }
        return;
      }
      if (key === "entityQuery") {
        setGlobalEntityFilter("");
        lastEntitySearchRows = [];
        renderLeftEntityContext();
        meetingSearchResultsEl.innerHTML = "";
        entitySearchResultsEl.innerHTML = "";
        contentSearchResultsEl.innerHTML = "";
        updateExplorationWorkspaceVisibility();
        void loadStoredMeetingsBrowse();
        return;
      }
      if (key === "entityType") {
        setGlobalEntityTypeFilter("");
        if ((entitySearchEl.value || "").trim()) {
          void searchEntities();
        } else {
          entitySearchResultsEl.innerHTML = "";
          meetingSearchResultsEl.innerHTML = "";
          updateExplorationWorkspaceVisibility();
          syncWorkspaceHeight();
        }
        return;
      }
      if (key === "meetingId") {
        setGlobalMeetingFilter(null);
        renderLeftEntityContext();
        void loadStoredMeetingsBrowse();
      }
    });
  </script>
</body>
</html>
